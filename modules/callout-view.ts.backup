import { ItemView, WorkspaceLeaf, Component, setIcon, MarkdownView, MarkdownRenderer } from 'obsidian';
import { CalloutItem, CalloutOrganizerSettings } from './types';
import { VIEW_TYPE_CALLOUT_ORGANIZER, OBSIDIAN_NOTE_ICON_SVG } from './constants';
import { filterHeadersBySettings, readableToTimestamp } from './utils';

// This is a simplified version of the CalloutOrganizerView class
// The full implementation would need to be extracted method by method from main.ts
// This provides the basic structure for the refactoring

export class CalloutOrganizerView extends ItemView {
    plugin: any; // CalloutOrganizerPlugin - will be typed properly when main.ts is refactored
    callouts: CalloutItem[] = [];
    component: Component;
    activeFilters: Set<string> = new Set();
    searchMode: 'current' | 'search';
    searchQuery: string = '';
    
    // Debouncing and performance optimizations
    private refreshDebounceTimer: NodeJS.Timeout | null = null;
    private searchDebounceTimer: NodeJS.Timeout | null = null;
    private lastRenderTime: number = 0;
    private readonly DEBOUNCE_DELAY = 300;
    private readonly RENDER_BATCH_SIZE = 20;
    private readonly MIN_RENDER_INTERVAL = 100;
    
    // DOM element cache for performance
    private cachedTypeSelectorContainer: HTMLElement | null = null;
    private topBarElement: HTMLElement | null = null;
    private calloutContainerElement: HTMLElement | null = null;
    private readonly SEARCH_DEBOUNCE_DELAY = 200;
    private readonly RENDER_DEBOUNCE_DELAY = 150;
    
    // Math processing optimization
    private mathProcessingQueue: HTMLElement[] = [];
    private mathProcessingActive = false;
    private intersectionObserver: IntersectionObserver | null = null;
    private mathCache = new Map<string, HTMLElement>();
    private pendingMathElements = new WeakSet<HTMLElement>();
    private readonly MAX_CONCURRENT_MATH = 3;
    private currentMathProcessing = 0;
    
    // Virtual scrolling optimization
    private virtualScrollContainer: HTMLElement | null = null;
    private virtualScrollObserver: IntersectionObserver | null = null;
    private visibleCalloutElements = new Map<string, HTMLElement>();
    private calloutElementPool: HTMLElement[] = [];
    private readonly VIRTUAL_BUFFER_SIZE = 10;
    private readonly ESTIMATED_CALLOUT_HEIGHT = 120;
    private isVirtualScrolling = false;

    constructor(leaf: WorkspaceLeaf, plugin: any, mode: 'current' | 'search' = 'current') {
        super(leaf);
        this.plugin = plugin;
        this.component = new Component();
        this.searchMode = mode;
    }

    getViewType() {
        return VIEW_TYPE_CALLOUT_ORGANIZER;
    }

    getDisplayText() {
        return this.searchMode === 'search' ? "Callout Search" : "Callout View";
    }

    getIcon() {
        return "album";
    }

    async onOpen() {
        this.component.load();
        const container = this.containerEl.children[1];
        container.empty();
        
        // Setup math observer for lazy processing
        this.setupMathObserver();
        
        // Top bar with mode toggle, search, and type selectors
        const topBar = container.createEl("div", { cls: "callout-top-bar" });
        this.setupTopBar(topBar);
        
        const calloutContainer = container.createEl("div", { cls: "callout-container" });
        this.calloutContainerElement = calloutContainer;
        this.renderCallouts(calloutContainer);
        
        await this.refreshCallouts();
    }

    async refreshCallouts() {
        if (this.searchMode === 'current') {
            this.callouts = await this.plugin.extractCurrentFileCallouts();
        } else if (this.searchMode === 'search') {
            // Load callouts from cache
            const cache = await this.plugin.loadCalloutCache();
            if (cache && cache.callouts) {
                this.callouts = cache.callouts;
            } else {
                this.callouts = [];
            }
        }
        
        // Update type selectors when callouts change
        if (this.cachedTypeSelectorContainer) {
            this.setupTypeSelectors(this.cachedTypeSelectorContainer);
        }
        
        const container = this.containerEl.querySelector('.callout-container');
        if (container) {
            await this.renderCallouts(container as HTMLElement);
        }
    }

    setupTopBar(container: HTMLElement) {
        container.empty();
        
        // First line: controls
        const firstLine = container.createEl("div", { cls: "callout-top-bar-line-1" });
        
        // Mode toggle button (left)
        const modeToggleBtn = firstLine.createEl("button", {
            text: this.searchMode === 'current' ? "Current File" : "All Files",
            cls: "callout-mode-toggle-button"
        });
        
        modeToggleBtn.onmousedown = async (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            if (this.searchMode === 'current') {
                this.searchMode = 'search';
                modeToggleBtn.textContent = "All Files";
            } else {
                this.searchMode = 'current';
                modeToggleBtn.textContent = "Current File";
                // Clear search query when switching to current file mode
                this.searchQuery = '';
            }
            
            // Clear existing filters and refresh callouts first
            this.activeFilters.clear();
            await this.refreshCallouts();
            
            // Now select all available callout types from refreshed data
            const uniqueTypes = new Set(this.callouts.map(callout => callout.type));
            uniqueTypes.forEach(type => this.activeFilters.add(type));
            
            await this.refreshCallouts();
        };
        
        // Search input (center)
        const searchInput = firstLine.createEl("input", {
            type: "text",
            placeholder: this.getSearchPlaceholder(),
            cls: "callout-search-input",
            value: this.searchQuery
        });
        
        searchInput.oninput = () => {
            this.searchQuery = searchInput.value;
            this.debouncedSearch();
        };
        
        // Update search input when mode changes
        if (this.searchQuery === '') {
            searchInput.value = '';
        }
        
        // Right side buttons container
        const rightButtons = firstLine.createEl("div", { cls: "callout-right-buttons" });
        
        // Refresh button
        const refreshBtn = rightButtons.createEl("button", {
            cls: "callout-refresh-button"
        });
        setIcon(refreshBtn, "refresh-cw");
        
        refreshBtn.onmousedown = async (e) => {
            e.preventDefault(); // Prevent focus issues
            if (this.searchMode === 'search') {
                // Force refresh by rescanning all files and updating cache
                if (this.plugin.refreshAllCallouts) {
                    await this.plugin.refreshAllCallouts();
                }
                
                // Then load from cache
                await this.refreshCallouts();
            } else {
                // For current file mode, refresh and also rebuild cache
                if (this.plugin.refreshAllCallouts) {
                    await this.plugin.refreshAllCallouts();
                }
                
                // Then refresh current file view
                await this.refreshCallouts();
            }
        };
        
        // Second line: type selectors
        const secondLine = container.createEl("div", { cls: "callout-top-bar-line-2" });
        const typeSelectors = secondLine.createEl("div", { cls: "callout-type-selectors" });
        this.cachedTypeSelectorContainer = typeSelectors;
        this.setupTypeSelectors(typeSelectors);
    }

    setupTypeSelectors(container: HTMLElement) {
        container.empty();
        
        // Get unique callout types from current callouts
        const uniqueTypes = [...new Set(this.callouts.map(c => c.type))].sort();
        
        if (uniqueTypes.length === 0) {
            container.createEl("p", { text: "No callout types found", cls: "callout-empty-message" });
            return;
        }
        
        // If no filters are active, show all types by default
        if (this.activeFilters.size === 0) {
            uniqueTypes.forEach(type => this.activeFilters.add(type));
        }
        
        // Add Select All/Clear All toggle button at the beginning
        if (uniqueTypes.length > 0) {
            const allSelected = this.activeFilters.size === uniqueTypes.length;
            const toggleButton = container.createEl("button", {
                text: allSelected ? "Clear All" : "Select All",
                cls: "callout-clear-all-button"
            });
            
            toggleButton.onmousedown = (e) => {
                e.preventDefault(); // Prevent focus issues
                e.stopPropagation();
                const currentlyAllSelected = this.activeFilters.size === uniqueTypes.length;
                
                if (currentlyAllSelected) {
                    // Clear all
                    this.activeFilters.clear();
                    
                    // Update all button states
                    const allButtons = container.querySelectorAll('.callout-type-selector');
                    allButtons.forEach(btn => btn.removeClass('active'));
                    
                    toggleButton.textContent = "Select All";
                } else {
                    // Select all
                    this.activeFilters.clear();
                    uniqueTypes.forEach(type => this.activeFilters.add(type));
                    
                    // Update all button states
                    const allButtons = container.querySelectorAll('.callout-type-selector');
                    allButtons.forEach(btn => btn.addClass('active'));
                    
                    toggleButton.textContent = "Clear All";
                }
                
                this.debouncedRender();
            };
        }
        
        // Create type selector buttons directly
        uniqueTypes.forEach(type => {
            const button = container.createEl("button", { 
                cls: `callout-type-selector callout-filter-${type}`
            });
            
            // Add icon if available, fallback to "note" type icon
            // For built-in callouts, check if user has actually customized the icon
            let iconName: string;
            if (this.plugin.isBuiltinCalloutType(type)) {
                const defaultIcon = this.plugin.getDefaultIconForCalloutType(type);
                const currentIcon = this.plugin.settings.calloutColors[type]?.icon;
                // Only use custom icon if it's different from the default
                iconName = (currentIcon && currentIcon !== defaultIcon) ? currentIcon : defaultIcon;
            } else {
                // For custom callouts, use the icon from settings or fallback
                iconName = this.plugin.settings.calloutColors[type]?.icon || 
                           this.plugin.settings.calloutColors['note']?.icon || 'pencil';
            }
            
            if (iconName && iconName !== 'none') {
                const iconEl = button.createEl("span", { cls: "callout-type-icon" });
                
                // Special handling for pencil icon to ensure we get the correct lucide-pencil
                if (iconName === 'pencil') {
                    iconEl.innerHTML = OBSIDIAN_NOTE_ICON_SVG;
                } else {
                    setIcon(iconEl, iconName);
                }
                
                iconEl.style.marginRight = "4px";
                iconEl.style.width = "calc(var(--callout-font-size, 14px) * 16 / 14)";
                iconEl.style.height = "calc(var(--callout-font-size, 14px) * 16 / 14)";
                iconEl.style.display = "inline-flex";
                iconEl.style.alignItems = "center";
            }
            
            if (this.activeFilters.has(type)) {
                button.addClass('active');
            }
            
            // Add type name
            button.createEl("span", { text: type });
            
            // Click handler using onmousedown for consistency with original
            button.onmousedown = (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                if (this.activeFilters.has(type)) {
                    this.activeFilters.delete(type);
                    button.removeClass('active');
                } else {
                    this.activeFilters.add(type);
                    button.addClass('active');
                }
                
                // Update Select All button
                const toggleButton = container.querySelector('.callout-clear-all-button') as HTMLButtonElement;
                if (toggleButton) {
                    const allSelected = this.activeFilters.size === uniqueTypes.length;
                    toggleButton.textContent = allSelected ? "Clear All" : "Select All";
                }
                
                this.debouncedRender();
            };
        });
    }

    private renderFilteredCallouts() {
        const container = this.containerEl.querySelector('.callout-container');
        if (container) {
            this.renderCallouts(container as HTMLElement);
        }
    }

    private debouncedSearch() {
        if (this.searchDebounceTimer) {
            clearTimeout(this.searchDebounceTimer);
        }
        
        // Adaptive debouncing based on result size
        const delay = this.callouts.length > 100 ? this.SEARCH_DEBOUNCE_DELAY * 2 : this.SEARCH_DEBOUNCE_DELAY;
        
        this.searchDebounceTimer = setTimeout(() => {
            this.searchDebounceTimer = null;
            const calloutContainer = this.calloutContainerElement || this.containerEl.querySelector('.callout-container') as HTMLElement;
            if (calloutContainer) {
                this.renderCallouts(calloutContainer);
            }
        }, delay);
    }

    private debouncedRender() {
        const now = Date.now();
        if (now - this.lastRenderTime < this.MIN_RENDER_INTERVAL) {
            return;
        }
        this.lastRenderTime = now;
        
        const calloutContainer = this.containerEl.querySelector('.callout-container');
        if (calloutContainer) {
            this.renderCallouts(calloutContainer as HTMLElement);
        }
    }

    getSearchPlaceholder(): string {
        if (this.searchMode === 'current') {
            return 'Search current file...';
        }
        return 'Search all callouts...';
    }

    // Enhanced math processing with caching and batching
    private processMathForElement(element: HTMLElement) {
        if (this.pendingMathElements.has(element)) {
            return; // Already queued for processing
        }
        
        this.pendingMathElements.add(element);
        this.mathProcessingQueue.push(element);
        
        if (!this.mathProcessingActive) {
            this.startMathProcessing();
        }
    }
    
    private startMathProcessing() {
        if (this.mathProcessingActive || this.mathProcessingQueue.length === 0) {
            return;
        }
        
        this.mathProcessingActive = true;
        this.processMathBatch();
    }
    
    private processMathBatch() {
        if (this.mathProcessingQueue.length === 0) {
            this.mathProcessingActive = false;
            return;
        }
        
        // Process a small batch to avoid blocking the UI
        const batchSize = Math.min(this.MAX_CONCURRENT_MATH, this.mathProcessingQueue.length);
        const batch = this.mathProcessingQueue.splice(0, batchSize);
        
        let processed = 0;
        
        const processBatchElement = async (element: HTMLElement) => {
            try {
                // Check cache first
                const mathContent = this.getMathContentHash(element);
                if (mathContent && this.mathCache.has(mathContent)) {
                    const cachedElement = this.mathCache.get(mathContent)!;
                    element.innerHTML = cachedElement.innerHTML;
                    this.pendingMathElements.delete(element);
                    processed++;
                    return;
                }
                
                // Process with MathJax
                const mathJax = (window as any).MathJax;
                if (mathJax && mathJax.typesetPromise) {
                    await mathJax.typesetPromise([element]);
                    // Cache the result
                    if (mathContent) {
                        const cached = element.cloneNode(true) as HTMLElement;
                        this.mathCache.set(mathContent, cached);
                    }
                } else if (mathJax && mathJax.Hub) {
                    // For MathJax 2, we can't easily await, so just queue
                    mathJax.Hub.Queue(["Typeset", mathJax.Hub, element]);
                }
                
                this.pendingMathElements.delete(element);
            } catch (error) {
                console.warn('Math processing error:', error);
                this.pendingMathElements.delete(element);
            }
            processed++;
        };
        
        // Process batch elements
        Promise.all(batch.map(processBatchElement)).then(() => {
            // Continue with next batch after a brief pause
            requestAnimationFrame(() => {
                this.processMathBatch();
            });
        });
    }
    
    private getMathContentHash(element: HTMLElement): string | null {
        // Create a simple hash of the math content for caching
        const mathElements = element.querySelectorAll('.math, [class*="math"], script[type="math/tex"]');
        if (mathElements.length === 0) return null;
        
        let content = '';
        mathElements.forEach(el => {
            content += el.textContent || '';
        });
        
        // Simple hash function
        let hash = 0;
        for (let i = 0; i < content.length; i++) {
            const char = content.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash; // Convert to 32-bit integer
        }
        return hash.toString();
    }
    
    // Lazy math processing using intersection observer
    private setupMathObserver() {
        if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
        }
        
        this.intersectionObserver = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const element = entry.target as HTMLElement;
                    // Process math for visible elements
                    const mathElements = element.querySelectorAll('.callout-organizer-content, .callout-organizer-title');
                    mathElements.forEach(mathEl => {
                        this.processMathForElement(mathEl as HTMLElement);
                    });
                    // Stop observing this element
                    this.intersectionObserver?.unobserve(element);
                }
            });
        }, {
            root: null,
            rootMargin: '100px', // Start processing math 100px before element is visible
            threshold: 0.1
        });
    }
    
    // Virtual scrolling implementation for better performance with large datasets
    private setupVirtualScrolling(container: HTMLElement, callouts: CalloutItem[]) {
        // Only enable virtual scrolling for large datasets
        if (callouts.length < 50) {
            this.isVirtualScrolling = false;
            return;
        }
        
        this.isVirtualScrolling = true;
        this.virtualScrollContainer = container;
        
        if (this.virtualScrollObserver) {
            this.virtualScrollObserver.disconnect();
        }
        
        // Create spacer elements for non-visible items
        const estimatedTotalHeight = callouts.length * this.ESTIMATED_CALLOUT_HEIGHT;
        const spacerTop = container.createEl('div', { cls: 'virtual-scroll-spacer-top' });
        const visibleContainer = container.createEl('div', { cls: 'virtual-scroll-visible' });
        const spacerBottom = container.createEl('div', { cls: 'virtual-scroll-spacer-bottom' });
        
        spacerTop.style.height = '0px';
        spacerBottom.style.height = estimatedTotalHeight + 'px';
        
        // Setup intersection observer for virtual scrolling
        this.virtualScrollObserver = new IntersectionObserver((entries) => {
            this.updateVirtualScrolling(callouts, spacerTop, visibleContainer, spacerBottom);
        }, {
            root: container,
            rootMargin: '200px',
            threshold: 0
        });
        
        // Observe the spacers
        this.virtualScrollObserver.observe(spacerTop);
        this.virtualScrollObserver.observe(spacerBottom);
        
        // Initial render
        this.updateVirtualScrolling(callouts, spacerTop, visibleContainer, spacerBottom);
    }
    
    private updateVirtualScrolling(
        callouts: CalloutItem[], 
        spacerTop: HTMLElement, 
        visibleContainer: HTMLElement, 
        spacerBottom: HTMLElement
    ) {
        if (!this.virtualScrollContainer) return;
        
        const scrollTop = this.virtualScrollContainer.scrollTop;
        const containerHeight = this.virtualScrollContainer.clientHeight;
        
        // Calculate visible range with buffer
        const startIndex = Math.max(0, Math.floor(scrollTop / this.ESTIMATED_CALLOUT_HEIGHT) - this.VIRTUAL_BUFFER_SIZE);
        const endIndex = Math.min(callouts.length - 1, 
            Math.floor((scrollTop + containerHeight) / this.ESTIMATED_CALLOUT_HEIGHT) + this.VIRTUAL_BUFFER_SIZE);
        
        // Update spacer heights
        const topSpacerHeight = startIndex * this.ESTIMATED_CALLOUT_HEIGHT;
        const bottomSpacerHeight = (callouts.length - endIndex - 1) * this.ESTIMATED_CALLOUT_HEIGHT;
        
        spacerTop.style.height = topSpacerHeight + 'px';
        spacerBottom.style.height = Math.max(0, bottomSpacerHeight) + 'px';
        
        // Render visible callouts
        this.renderVisibleCallouts(callouts.slice(startIndex, endIndex + 1), visibleContainer, startIndex);
    }
    
    private renderVisibleCallouts(visibleCallouts: CalloutItem[], container: HTMLElement, startIndex: number) {
        // Clear container but reuse elements when possible
        const existingElements = Array.from(container.children) as HTMLElement[];
        
        // Hide excess elements
        for (let i = visibleCallouts.length; i < existingElements.length; i++) {
            existingElements[i].style.display = 'none';
        }
        
        // Render each visible callout
        visibleCallouts.forEach((callout, index) => {
            let calloutEl = existingElements[index];
            
            if (!calloutEl) {
                // Create new element or reuse from pool
                calloutEl = this.getPooledCalloutElement();
                container.appendChild(calloutEl);
            } else {
                calloutEl.style.display = '';
            }
            
            // Update the element with new callout data
            this.updateCalloutElement(calloutEl, callout, startIndex + index);
        });
    }
    
    private getPooledCalloutElement(): HTMLElement {
        if (this.calloutElementPool.length > 0) {
            return this.calloutElementPool.pop()!;
        }
        
        // Create new element with basic structure
        const calloutEl = document.createElement('div');
        calloutEl.className = 'callout-organizer-item callout';
        calloutEl.style.cursor = 'pointer';
        calloutEl.draggable = true;
        
        return calloutEl;
    }
    
    private returnElementToPool(element: HTMLElement) {
        element.innerHTML = '';
        element.style.display = 'none';
        this.calloutElementPool.push(element);
    }
    
    private updateCalloutElement(calloutEl: HTMLElement, callout: CalloutItem, index: number) {
        // Clear and rebuild the element content
        calloutEl.innerHTML = '';
        calloutEl.setAttribute('data-callout', callout.type);
        calloutEl.style.display = '';
        
        // This method would contain the same logic as the current renderCallouts
        // but for a single callout element. For brevity, I'll reference the existing logic
        this.renderSingleCallout(calloutEl, callout);
    }
    
    private renderSingleCallout(calloutEl: HTMLElement, callout: CalloutItem) {
        // Add drag functionality
        let pendingCalloutId: string | null = null;
        
        calloutEl.ondragstart = (e) => {
            if (e.dataTransfer) {
                // Check if we need to generate a new callout ID
                let calloutID = callout.calloutID;
                
                if (!calloutID) {
                    calloutID = this.plugin.generateCalloutId(callout);
                    callout.calloutID = calloutID;
                    pendingCalloutId = calloutID || null;
                }
                
                // Generate link text based on settings
                let linkText: string;
                const fileNamePart = callout.file.replace(/\.md$/, '');
                const linkTarget = `${fileNamePart}#^${calloutID}`;

                if (this.plugin.settings.useEmbedLinks) {
                    if (this.plugin.settings.hideFileNamesInLinks) {
                        linkText = `![[${linkTarget}|${calloutID}]]`;
                    } else {
                        linkText = `![[${linkTarget}]]`;
                    }
                } else {
                    if (this.plugin.settings.hideFileNamesInLinks) {
                        linkText = `[[${linkTarget}|${calloutID}]]`;
                    } else {
                        linkText = `[[${linkTarget}]]`;
                    }
                }
                e.dataTransfer.setData('text/plain', linkText);
                e.dataTransfer.effectAllowed = 'copy';
                calloutEl.style.opacity = '0.5';
            }
        };
        
        calloutEl.ondragend = () => {
            calloutEl.style.opacity = '1';
            if (pendingCalloutId) {
                setTimeout(async () => {
                    try {
                        await this.plugin.addCalloutIdToCallout(callout, pendingCalloutId!);
                        await this.plugin.saveCalloutCache(this.callouts);
                        pendingCalloutId = null;
                    } catch (error) {
                        console.error('Error adding callout ID to file:', error);
                        callout.calloutID = undefined;
                        pendingCalloutId = null;
                    }
                }, 100);
            }
        };
        
        // Create header with title and canvas button
        const header = calloutEl.createEl('div', { cls: 'callout-organizer-header' });
        header.style.cssText = 'display: flex; align-items: center; gap: 8px;';
        
        const displayTitle = callout.title || callout.type.charAt(0).toUpperCase() + callout.type.slice(1);
        
        if (displayTitle) {
            const titleEl = header.createEl('span', { cls: 'callout-organizer-title' });
            const calloutColor = this.plugin.settings.calloutColors[callout.type]?.color || 
                                this.plugin.settings.calloutColors['note']?.color || 'var(--callout-title-color)';
            
            // Add icon
            let iconName: string;
            if (this.plugin.isBuiltinCalloutType(callout.type)) {
                const defaultIcon = this.plugin.getDefaultIconForCalloutType(callout.type);
                const currentIcon = this.plugin.settings.calloutColors[callout.type]?.icon;
                iconName = (currentIcon && currentIcon !== defaultIcon) ? currentIcon : defaultIcon;
            } else {
                iconName = this.plugin.settings.calloutColors[callout.type]?.icon || 
                          this.plugin.settings.calloutColors['note']?.icon || 'pencil';
            }
            
            if (iconName && iconName !== 'none') {
                const iconEl = titleEl.createEl('span', { cls: 'callout-title-icon' });
                if (iconName === 'pencil') {
                    iconEl.innerHTML = OBSIDIAN_NOTE_ICON_SVG;
                } else {
                    setIcon(iconEl, iconName);
                }
                iconEl.style.cssText = `margin-right: 6px; width: calc(var(--callout-font-size, 14px) * 16 / 14); height: calc(var(--callout-font-size, 14px) * 16 / 14); display: inline-flex; align-items: center; color: ${calloutColor};`;
            }
            
            titleEl.style.color = calloutColor;
            
            MarkdownRenderer.render(this.app, displayTitle, titleEl, callout.file, this.component).then(() => {
                titleEl.style.color = calloutColor;
            }).catch((error) => {
                console.warn('Failed to render callout title:', error);
                titleEl.textContent = displayTitle;
                titleEl.style.color = calloutColor;
            });
        }
        
        // Add canvas button
        const canvasBtn = header.createEl('button', { 
            cls: 'callout-canvas-button',
            title: 'Open in Canvas'
        });
        setIcon(canvasBtn, 'layout-dashboard');
        canvasBtn.style.cssText = 'margin-left: auto; padding: 4px; border: none; background: var(--interactive-normal); border-radius: 4px; cursor: pointer; display: flex; align-items: center; justify-content: center; width: 24px; height: 24px;';
        
        canvasBtn.onmouseover = () => canvasBtn.style.background = 'var(--interactive-hover)';
        canvasBtn.onmouseleave = () => canvasBtn.style.background = 'var(--interactive-normal)';
        canvasBtn.onclick = (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.openCalloutCanvas(callout);
        };
        
        // Add content
        const content = calloutEl.createEl('div', { cls: 'callout-organizer-content' });
        MarkdownRenderer.render(this.app, callout.content, content, callout.file, this.component).catch((error) => {
            console.warn('Failed to render callout content:', error);
            content.textContent = callout.content;
        });
        
        // Add breadcrumb
        const breadcrumb = calloutEl.createEl('div', { cls: 'callout-organizer-breadcrumb' });
        
        if (this.plugin.settings.showFilenames && callout.file) {
            const fileParts = callout.file?.split('/');
            const filename = fileParts?.pop()?.replace(/\.md$/, '') || callout.file || 'Unknown';
            const fileLink = breadcrumb.createEl('a', { 
                text: filename,
                href: '#',
                cls: 'callout-organizer-file-link'
            });
            fileLink.onclick = (e) => {
                e.preventDefault();
                if (this.plugin.openFile) {
                    this.plugin.openFile(callout.file, callout.lineNumber, e.ctrlKey || e.metaKey);
                }
            };
        }
        
        // Add headers and callout ID to breadcrumb (simplified)
        if (callout.headers && callout.headers.length > 0) {
            const filteredHeaders = filterHeadersBySettings(callout.headers, callout.headerLevels, this.plugin.settings);
            filteredHeaders.forEach(headerTitle => {
                if (breadcrumb.children.length > 0) {
                    breadcrumb.createEl('span', { text: ' > ', cls: 'callout-organizer-breadcrumb-separator' });
                }
                const headingLink = breadcrumb.createEl('a', {
                    text: headerTitle,
                    href: '#',
                    cls: 'callout-organizer-heading-link'
                });
                headingLink.onclick = (e) => {
                    e.preventDefault();
                    if (this.plugin.openFile) {
                        this.plugin.openFile(callout.file, callout.lineNumber, e.ctrlKey || e.metaKey);
                    }
                };
            });
        }
        
        if (callout.calloutID && this.plugin.settings.showCalloutIds) {
            if (breadcrumb.children.length > 0) {
                breadcrumb.createEl('span', { text: ' > ', cls: 'callout-organizer-breadcrumb-separator' });
            }
            const blockLink = breadcrumb.createEl('a', {
                text: `^${callout.calloutID}`,
                href: '#',
                cls: 'callout-organizer-callout-id'
            });
            blockLink.onclick = (e) => {
                e.preventDefault();
                if (this.plugin.openFile) {
                    this.plugin.openFile(callout.file, callout.lineNumber, e.ctrlKey || e.metaKey);
                }
            };
        }
        
        // Main click handler
        calloutEl.onclick = async (e) => {
            if ((e.target as HTMLElement).tagName === 'A') {
                return;
            }
            e.preventDefault();
            if (this.plugin.openFile) {
                await this.plugin.openFile(callout.file, callout.lineNumber, e.ctrlKey || e.metaKey);
            }
        };
        
        // Add to intersection observer for math processing
        if (this.intersectionObserver) {
            this.intersectionObserver.observe(calloutEl);
        }
    }

    // Canvas integration method
    async openCalloutCanvas(callout: CalloutItem) {
        if (this.plugin.openCalloutCanvas) {
            await this.plugin.openCalloutCanvas(callout);
        }
    }

    async renderCallouts(container: HTMLElement) {
        container.empty();
        
        const calloutsList = container.createEl("div", { cls: "callouts-list" });
        const filteredCallouts = this.getFilteredCallouts();
        
        if (filteredCallouts.length === 0) {
            const emptyMessage = calloutsList.createEl("div", { 
                cls: "callout-empty-message",
                text: "No callouts found"
            });
            return;
        }
        
        // Sort callouts based on mode
        const sortedCallouts = [...filteredCallouts].sort((a, b) => {
            if (this.searchMode === 'search') {
                // In all files mode, sort by callout modification time (recent first)
                const aModTime = a.calloutModifyTime || a.fileModTime || '1970-01-01 00:00:00';
                const bModTime = b.calloutModifyTime || b.fileModTime || '1970-01-01 00:00:00';
                return readableToTimestamp(bModTime) - readableToTimestamp(aModTime);
            } else {
                // In current file mode, sort by line number
                return a.lineNumber - b.lineNumber;
            }
        });
        
        // Use virtual scrolling for large datasets
        if (sortedCallouts.length >= 50) {
            this.setupVirtualScrolling(calloutsList, sortedCallouts);
            return;
        }
        
        // Regular rendering for smaller datasets
        for (const callout of sortedCallouts) {
            // Use the same class structure as the original
            const calloutEl = calloutsList.createEl("div", { 
                cls: "callout-organizer-item callout",
                attr: { 'data-callout': callout.type }
            });
            
            // Make entire callout clickable and draggable
            calloutEl.style.cursor = "pointer";
            calloutEl.draggable = true;
            
            // Add drag functionality
            let pendingCalloutId: string | null = null;
            
            calloutEl.ondragstart = (e) => {
                if (e.dataTransfer) {
                    // Check if we need to generate a new callout ID
                    let calloutID = callout.calloutID;
                    
                    if (!calloutID) {
                        calloutID = this.plugin.generateCalloutId(callout);
                        callout.calloutID = calloutID;
                        pendingCalloutId = calloutID || null; // Store for later addition to file
                    }
                    
                    // Generate link text based on settings
                    let linkText: string;
                    const fileNamePart = callout.file.replace(/\.md$/, '');
                    const linkTarget = `${fileNamePart}#^${calloutID}`;

                    if (this.plugin.settings.useEmbedLinks) {
                        // Use embed format: ![[...]]
                        if (this.plugin.settings.hideFileNamesInLinks) {
                            linkText = `![[${linkTarget}|${calloutID}]]`; // Hide filename with alias
                        } else {
                            linkText = `![[${linkTarget}]]`; // Show full path
                        }
                    } else {
                        // Use regular link format: [[...]]
                        if (this.plugin.settings.hideFileNamesInLinks) {
                            linkText = `[[${linkTarget}|${calloutID}]]`; // Hide filename with alias
                        } else {
                            linkText = `[[${linkTarget}]]`; // Show full path
                        }
                    }
                    e.dataTransfer.setData('text/plain', linkText);
                    
                    e.dataTransfer.effectAllowed = 'copy';
                    
                    // Add visual feedback during drag
                    calloutEl.style.opacity = '0.5';
                }
            };
            
            calloutEl.ondragend = () => {
                // Restore opacity after drag
                calloutEl.style.opacity = '1';
                
                // Add callout ID to file after drag is complete (prevents infinite loop)
                if (pendingCalloutId) {
                    // Use setTimeout to ensure this happens after the drag operation is fully complete
                    setTimeout(async () => {
                        try {
                            await this.plugin.addCalloutIdToCallout(callout, pendingCalloutId!);
                            // Update cache after successful ID addition
                            await this.plugin.saveCalloutCache(this.callouts);
                            pendingCalloutId = null;
                        } catch (error) {
                            console.error('Error adding callout ID to file:', error);
                            // Reset the callout ID if we failed to add it to the file
                            callout.calloutID = undefined;
                            pendingCalloutId = null;
                        }
                    }, 100); // Small delay to ensure drag operation is complete
                }
            };
            
            // Header with type and title (matching original structure)
            const header = calloutEl.createEl("div", { cls: "callout-organizer-header" });
            header.style.display = "flex";
            header.style.alignItems = "center";
            header.style.gap = "8px";
            
            // Use callout title if available, otherwise use callout type
            const displayTitle = callout.title || callout.type.charAt(0).toUpperCase() + callout.type.slice(1);
            
            if (displayTitle) {
                const titleEl = header.createEl("span", { 
                    cls: "callout-organizer-title"
                });
                
                // Get callout color for styling, fallback to "note" type color
                const calloutColor = this.plugin.settings.calloutColors[callout.type]?.color || 
                                    this.plugin.settings.calloutColors['note']?.color || 'var(--callout-title-color)';
                
                // Always add icon (for both custom titles and type titles), fallback to "note" type icon
                // For built-in callouts, check if user has actually customized the icon
                let iconName: string;
                if (this.plugin.isBuiltinCalloutType(callout.type)) {
                    const defaultIcon = this.plugin.getDefaultIconForCalloutType(callout.type);
                    const currentIcon = this.plugin.settings.calloutColors[callout.type]?.icon;
                    // Only use custom icon if it's different from the default
                    iconName = (currentIcon && currentIcon !== defaultIcon) ? currentIcon : defaultIcon;
                } else {
                    // For custom callouts, use the icon from settings or fallback
                    iconName = this.plugin.settings.calloutColors[callout.type]?.icon || 
                               this.plugin.settings.calloutColors['note']?.icon || 'pencil';
                }
                
                if (iconName && iconName !== 'none') {
                    const iconEl = titleEl.createEl("span", { cls: "callout-title-icon" });
                    
                    // Special handling for pencil icon to ensure we get the correct lucide-pencil
                    if (iconName === 'pencil') {
                        iconEl.innerHTML = OBSIDIAN_NOTE_ICON_SVG;
                    } else {
                        setIcon(iconEl, iconName);
                    }
                    
                    iconEl.style.marginRight = "6px";
                    iconEl.style.width = "calc(var(--callout-font-size, 14px) * 16 / 14)";
                    iconEl.style.height = "calc(var(--callout-font-size, 14px) * 16 / 14)";
                    iconEl.style.display = "inline-flex";
                    iconEl.style.alignItems = "center";
                    iconEl.style.color = calloutColor;
                }
                
                // Apply callout color to title text
                titleEl.style.color = calloutColor;
                
                // Render title with optimized math support
                MarkdownRenderer.render(this.app, displayTitle, titleEl, callout.file, this.component).then(() => {
                    // Reapply color after markdown rendering
                    titleEl.style.color = calloutColor;
                    // Math processing will be handled by intersection observer
                }).catch((error) => {
                    console.warn('Failed to render callout title:', error);
                    // Fallback to plain text
                    titleEl.textContent = displayTitle;
                    titleEl.style.color = calloutColor;
                });
            }
            
            // Add canvas button for all callouts
            {
                const canvasBtn = header.createEl("button", { 
                    cls: "callout-canvas-button",
                    title: "Open in Canvas"
                });
                setIcon(canvasBtn, "layout-dashboard");
                canvasBtn.style.marginLeft = "auto";
                canvasBtn.style.padding = "4px";
                canvasBtn.style.border = "none";
                canvasBtn.style.background = "var(--interactive-normal)";
                canvasBtn.style.borderRadius = "4px";
                canvasBtn.style.cursor = "pointer";
                canvasBtn.style.display = "flex";
                canvasBtn.style.alignItems = "center";
                canvasBtn.style.justifyContent = "center";
                canvasBtn.style.width = "24px";
                canvasBtn.style.height = "24px";
                
                canvasBtn.onmouseover = () => {
                    canvasBtn.style.background = "var(--interactive-hover)";
                };
                canvasBtn.onmouseleave = () => {
                    canvasBtn.style.background = "var(--interactive-normal)";
                };
                
                canvasBtn.onclick = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    this.openCalloutCanvas(callout);
                };
            }
            
            // Content with full markdown support (optimized)
            const content = calloutEl.createEl("div", { cls: "callout-organizer-content" });
            
            // Render full markdown content with lazy math support
            MarkdownRenderer.render(this.app, callout.content, content, callout.file, this.component).then(() => {
                // Math processing will be handled by intersection observer when visible
            }).catch((error) => {
                console.warn('Failed to render callout content:', error);
                // Fallback to plain text
                content.textContent = callout.content;
            });
            
            // Add the callout to intersection observer for lazy math processing
            if (this.intersectionObserver) {
                this.intersectionObserver.observe(calloutEl);
            }
        }
            
            // Build hierarchical breadcrumb (at the bottom, matching original implementation)
            const breadcrumb = calloutEl.createEl("div", { cls: "callout-organizer-breadcrumb" });
            
            // Add filename if enabled in settings
            if (this.plugin.settings.showFilenames && callout.file) {
                const fileParts = callout.file?.split('/');
                const filename = fileParts?.pop()?.replace(/\.md$/, '') || callout.file || 'Unknown';
                const fileLink = breadcrumb.createEl("a", { 
                    text: filename,
                    href: "#",
                    cls: "callout-organizer-file-link"
                });
                fileLink.onclick = (e) => {
                    e.preventDefault();
                    if (this.plugin.openFile) {
                        this.plugin.openFile(callout.file, callout.lineNumber, e.ctrlKey || e.metaKey);
                    }
                };
            }
            
            // Add heading hierarchy from stored headers, filtered by settings
            if (callout.headers && callout.headers.length > 0) {
                const filteredHeaders = filterHeadersBySettings(callout.headers, callout.headerLevels, this.plugin.settings);
                for (const headerTitle of filteredHeaders) {
                    if (breadcrumb.children.length > 0) {
                        breadcrumb.createEl("span", { 
                            text: " > ",
                            cls: "callout-organizer-breadcrumb-separator"
                        });
                    }
                    
                    const headingLink = breadcrumb.createEl("a", {
                        text: headerTitle,
                        href: "#",
                        cls: "callout-organizer-heading-link"
                    });
                    headingLink.onclick = (e) => {
                        e.preventDefault();
                        if (this.plugin.openFile) {
                            this.plugin.openFile(callout.file, callout.lineNumber, e.ctrlKey || e.metaKey);
                        }
                    };
                }
            }
            
            // Add callout-id if present and enabled in settings
            if (callout.calloutID && this.plugin.settings.showCalloutIds) {
                if (breadcrumb.children.length > 0) {
                    breadcrumb.createEl("span", { 
                        text: " > ",
                        cls: "callout-organizer-breadcrumb-separator"
                    });
                }
                const blockLink = breadcrumb.createEl("a", {
                    text: `^${callout.calloutID}`,
                    href: "#",
                    cls: "callout-organizer-callout-id"
                });
                blockLink.onclick = (e) => {
                    e.preventDefault();
                    if (this.plugin.openFile) {
                        this.plugin.openFile(callout.file, callout.lineNumber, e.ctrlKey || e.metaKey);
                    }
                };
            }
            
            // Click handler to open file
            calloutEl.onclick = async (e) => {
                // Don't trigger if clicking on links in breadcrumb
                if ((e.target as HTMLElement).tagName === 'A') {
                    return;
                }
                e.preventDefault();
                if (this.plugin.openFile) {
                    await this.plugin.openFile(callout.file, callout.lineNumber, e.ctrlKey || e.metaKey);
                }
            };
        }
    }

    getFilteredCallouts(): CalloutItem[] {
        // If no filters are active, return empty array (show nothing)
        if (this.activeFilters.size === 0) {
            return [];
        }
        
        // Apply type filters
        let filteredCallouts = this.callouts.filter(callout => 
            this.activeFilters.has(callout.type.toLowerCase())
        );
        
        // Apply search query
        if (this.searchQuery.trim()) {
            const query = this.searchQuery.toLowerCase();
            const keywords = query.split(/\s+/).filter(k => k.length > 0);
            const settings = this.plugin.settings; // Cache settings reference
            
            filteredCallouts = filteredCallouts.filter(callout => {
                // Build search text efficiently by concatenating enabled fields
                let searchText = '';
                
                if (this.searchMode === 'search') {
                    // In search mode, use settings configuration
                    if (settings.searchInFilenames) {
                        searchText += callout.file.toLowerCase() + ' ';
                    }
                    if (settings.searchInCalloutTitles) {
                        searchText += callout.title.toLowerCase() + ' ';
                    }
                    if (settings.searchInCalloutIds && callout.calloutID) {
                        searchText += callout.calloutID.toLowerCase() + ' ';
                    }
                    if (settings.searchInCalloutContent) {
                        searchText += callout.content.toLowerCase() + ' ';
                    }
                } else {
                    // In current file mode, search all fields
                    searchText += callout.file.toLowerCase() + ' ';
                    if (callout.headers) {
                        searchText += callout.headers.join(' ').toLowerCase() + ' ';
                    }
                    searchText += callout.title.toLowerCase() + ' ';
                    if (callout.calloutID) {
                        searchText += callout.calloutID.toLowerCase() + ' ';
                    }
                    searchText += callout.content.toLowerCase() + ' ';
                }
                
                // All keywords must be present (AND logic)
                return keywords.every(keyword => searchText.includes(keyword));
            });
        }
        
        // Apply maximum results limit only in search mode (all files mode)
        if (this.searchMode === 'search' && filteredCallouts.length > this.plugin.settings.maxSearchResults) {
            filteredCallouts = filteredCallouts.slice(0, this.plugin.settings.maxSearchResults);
        }
        
        return filteredCallouts;
    }

    async onClose() {
        this.component.unload();
        
        // Clean up timers
        if (this.refreshDebounceTimer) {
            clearTimeout(this.refreshDebounceTimer);
            this.refreshDebounceTimer = null;
        }
        if (this.searchDebounceTimer) {
            clearTimeout(this.searchDebounceTimer);
            this.searchDebounceTimer = null;
        }
        
        // Clean up intersection observers
        if (this.intersectionObserver) {
            this.intersectionObserver.disconnect();
            this.intersectionObserver = null;
        }
        if (this.virtualScrollObserver) {
            this.virtualScrollObserver.disconnect();
            this.virtualScrollObserver = null;
        }
        
        // Clear math processing resources
        this.mathProcessingQueue = [];
        this.mathProcessingActive = false;
        this.mathCache.clear();
        
        // Clear virtual scrolling resources
        this.visibleCalloutElements.clear();
        this.calloutElementPool = [];
        this.virtualScrollContainer = null;
    }

    // TODO: The following methods need to be extracted from main.ts:
    // - setupTypeSelectors
    // - renderSingleCallout  
    // - generateCalloutId
    // - addCalloutIdToCallout
    // - openFile
    // - openCalloutCanvas
    // - highlightLine
    // - groupCallouts
    // - filterHeadersBySettings
    // - getHeadingHierarchy
    // - detectAndAddNewCalloutTypes
    // And many more rendering and interaction methods
}