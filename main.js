/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CalloutOrganizerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var OBSIDIAN_NOTE_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-pencil"><path d="M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"></path><path d="m15 5 4 4"></path></svg>`;
var DEFAULT_SETTINGS = {
  excludedFolders: [],
  groupByType: false,
  // Show in file order by default
  searchInFilenames: true,
  searchInCalloutTitles: true,
  searchInCalloutIds: true,
  searchInCalloutContent: true,
  maxSearchResults: 50,
  // Cache settings (always enabled)
  // Canvas settings
  canvasStorageFolder: "Callout Connections",
  // Display options - show all by default
  showFilenames: true,
  showH1Headers: true,
  showH2Headers: true,
  showH3Headers: true,
  showH4Headers: true,
  showH5Headers: true,
  showH6Headers: true,
  showCalloutIds: true,
  calloutFontSize: 14,
  breadcrumbFontSize: 12,
  // Drag options
  useEmbedLinks: true,
  // Use embed links by default
  invisibleEmbeddings: true,
  // Enable invisible embeddings by default
  hideFileNamesInLinks: false,
  // Hide file names in links by default (disabled)
  // Callout options
  customCalloutCSS: "",
  // Callout colors will be dynamically populated based on detected callouts in vault
  calloutColors: {}
};
var VIEW_TYPE_CALLOUT_ORGANIZER = "callout-organizer";
function timestampToReadable(timestamp) {
  const date = new Date(timestamp);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  const hours = String(date.getHours()).padStart(2, "0");
  const minutes = String(date.getMinutes()).padStart(2, "0");
  const seconds = String(date.getSeconds()).padStart(2, "0");
  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}
function readableToTimestamp(readable) {
  return new Date(readable).getTime();
}
function hasCalloutChanged(newCallout, existingCallout) {
  return newCallout.type !== existingCallout.type || newCallout.title !== existingCallout.title || newCallout.content !== existingCallout.content;
}
var CalloutOrganizerView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin, mode = "current") {
    super(leaf);
    this.callouts = [];
    this.activeFilters = /* @__PURE__ */ new Set();
    this.searchQuery = "";
    // Debouncing and performance optimizations
    this.refreshDebounceTimer = null;
    this.searchDebounceTimer = null;
    this.lastRenderTime = 0;
    this.DEBOUNCE_DELAY = 300;
    this.RENDER_BATCH_SIZE = 20;
    // Batch DOM operations
    this.MIN_RENDER_INTERVAL = 100;
    // DOM element cache for performance
    this.cachedTypeSelectorContainer = null;
    // Performance optimization: cache DOM elements
    this.topBarElement = null;
    this.calloutContainerElement = null;
    this.SEARCH_DEBOUNCE_DELAY = 200;
    this.RENDER_DEBOUNCE_DELAY = 150;
    this.plugin = plugin;
    this.component = new import_obsidian.Component();
    this.searchMode = mode;
  }
  getViewType() {
    return VIEW_TYPE_CALLOUT_ORGANIZER;
  }
  getDisplayText() {
    return this.searchMode === "search" ? "Callout Search" : "Callout View";
  }
  getIcon() {
    return "album";
  }
  async onOpen() {
    this.component.load();
    const container = this.containerEl.children[1];
    container.empty();
    const topBar = container.createEl("div", { cls: "callout-top-bar" });
    this.setupTopBar(topBar);
    const calloutContainer = container.createEl("div", { cls: "callout-container" });
    this.renderCallouts(calloutContainer);
    await this.refreshCallouts();
  }
  async refreshCallouts() {
    if (this.searchMode === "current") {
      this.callouts = await this.plugin.extractCurrentFileCallouts();
    } else if (this.searchMode === "search") {
      const cache = await this.plugin.loadCalloutCache();
      if (cache && cache.callouts) {
        this.callouts = cache.callouts;
      } else {
        this.callouts = [];
      }
    }
    await this.detectAndAddNewCalloutTypes();
    if (!this.cachedTypeSelectorContainer) {
      this.cachedTypeSelectorContainer = this.containerEl.querySelector(".callout-type-selectors");
    }
    if (this.cachedTypeSelectorContainer) {
      this.setupTypeSelectors(this.cachedTypeSelectorContainer);
    }
    const container = this.containerEl.querySelector(".callout-container");
    if (container) {
      await this.renderCallouts(container);
    }
  }
  // Helper method to detect and add new callout types to settings
  async detectAndAddNewCalloutTypes() {
    var _a, _b;
    const currentTypes = new Set(this.callouts.map((c) => c.type.toLowerCase().trim()));
    let settingsChanged = false;
    for (const type of currentTypes) {
      if (!this.plugin.settings.calloutColors[type]) {
        const noteColor = ((_a = this.plugin.settings.calloutColors["note"]) == null ? void 0 : _a.color) || "#086DDD";
        const noteIcon = ((_b = this.plugin.settings.calloutColors["note"]) == null ? void 0 : _b.icon) || "pencil";
        this.plugin.settings.calloutColors[type] = {
          color: noteColor,
          icon: noteIcon
        };
        settingsChanged = true;
      }
    }
    if (settingsChanged) {
      await this.plugin.saveSettings();
      this.plugin.injectCustomCalloutCSS();
    }
  }
  async getHeadingHierarchy(callout) {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      return [];
    }
    const content = await this.app.vault.read(activeFile);
    const lines = content.split("\n");
    const headings = [];
    for (let i = 0; i < callout.lineNumber - 1; i++) {
      const line = lines[i].trim();
      const headingMatch = line.match(/^(#{1,6})\s+(.+)$/);
      if (headingMatch) {
        const level = headingMatch[1].length;
        const title = headingMatch[2].trim();
        headings.push({
          title,
          level,
          lineNumber: i + 1
        });
      }
    }
    const hierarchy = [];
    for (const heading of headings) {
      while (hierarchy.length > 0 && hierarchy[hierarchy.length - 1].level >= heading.level) {
        hierarchy.pop();
      }
      hierarchy.push(heading);
    }
    return hierarchy;
  }
  filterHeadersBySettings(headers, headerLevels) {
    if (!headerLevels || headers.length !== headerLevels.length) {
      return headers;
    }
    const filtered = [];
    for (let i = 0; i < headers.length; i++) {
      const level = headerLevels[i];
      let shouldInclude = false;
      switch (level) {
        case 1:
          shouldInclude = this.plugin.settings.showH1Headers;
          break;
        case 2:
          shouldInclude = this.plugin.settings.showH2Headers;
          break;
        case 3:
          shouldInclude = this.plugin.settings.showH3Headers;
          break;
        case 4:
          shouldInclude = this.plugin.settings.showH4Headers;
          break;
        case 5:
          shouldInclude = this.plugin.settings.showH5Headers;
          break;
        case 6:
          shouldInclude = this.plugin.settings.showH6Headers;
          break;
        default:
          shouldInclude = true;
      }
      if (shouldInclude) {
        filtered.push(headers[i]);
      }
    }
    return filtered;
  }
  getSearchPlaceholder() {
    if (this.searchMode === "current") {
      return "Search current file...";
    }
    const enabledFields = [];
    if (this.plugin.settings.searchInFilenames)
      enabledFields.push("files");
    if (this.plugin.settings.searchInCalloutTitles)
      enabledFields.push("callout titles");
    if (this.plugin.settings.searchInCalloutIds)
      enabledFields.push("callout IDs");
    if (this.plugin.settings.searchInCalloutContent)
      enabledFields.push("callout content");
    if (enabledFields.length === 0) {
      return "Search disabled - enable search fields in settings";
    }
    return "Search all files...";
  }
  setupTopBar(container) {
    container.empty();
    const firstLine = container.createEl("div", { cls: "callout-top-bar-line-1" });
    const modeToggleBtn = firstLine.createEl("button", {
      text: this.searchMode === "current" ? "Current File" : "All Files",
      cls: "callout-mode-toggle-button"
    });
    modeToggleBtn.onmousedown = async (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (this.searchMode === "current") {
        this.searchMode = "search";
        modeToggleBtn.textContent = "All Files";
      } else {
        this.searchMode = "current";
        modeToggleBtn.textContent = "Current File";
        this.searchQuery = "";
      }
      this.activeFilters.clear();
      await this.refreshCallouts();
      const uniqueTypes = new Set(this.callouts.map((callout) => callout.type));
      uniqueTypes.forEach((type) => this.activeFilters.add(type));
      await this.refreshCallouts();
    };
    const searchInput = firstLine.createEl("input", {
      type: "text",
      placeholder: this.getSearchPlaceholder(),
      cls: "callout-search-input",
      value: this.searchQuery
    });
    searchInput.oninput = () => {
      this.searchQuery = searchInput.value;
      this.debouncedSearch();
    };
    const rightButtons = firstLine.createEl("div", { cls: "callout-right-buttons" });
    const refreshBtn = rightButtons.createEl("button", {
      cls: "callout-refresh-button"
    });
    (0, import_obsidian.setIcon)(refreshBtn, "refresh-cw");
    refreshBtn.onmousedown = async (e) => {
      e.preventDefault();
      if (this.searchMode === "search") {
        await this.plugin.refreshAllCallouts();
        await this.refreshCallouts();
      } else {
        await this.plugin.refreshAllCallouts();
        await this.refreshCallouts();
      }
    };
    const secondLine = container.createEl("div", { cls: "callout-top-bar-line-2" });
    const typeSelectors = secondLine.createEl("div", { cls: "callout-type-selectors" });
    this.setupTypeSelectors(typeSelectors);
  }
  setupTypeSelectors(container) {
    container.empty();
    const uniqueTypes = [...new Set(this.callouts.map((c) => c.type))].sort();
    if (uniqueTypes.length === 0) {
      container.createEl("p", { text: "No callout types found", cls: "callout-empty-message" });
      return;
    }
    if (this.activeFilters.size === 0) {
      uniqueTypes.forEach((type) => this.activeFilters.add(type));
    }
    if (uniqueTypes.length > 0) {
      const allSelected = this.activeFilters.size === uniqueTypes.length;
      const toggleButton = container.createEl("button", {
        text: allSelected ? "Clear All" : "Select All",
        cls: "callout-clear-all-button"
      });
      toggleButton.onmousedown = (e) => {
        e.preventDefault();
        e.stopPropagation();
        const currentlyAllSelected = this.activeFilters.size === uniqueTypes.length;
        if (currentlyAllSelected) {
          this.activeFilters.clear();
          const allButtons = container.querySelectorAll(".callout-type-selector");
          allButtons.forEach((btn) => btn.removeClass("active"));
          toggleButton.textContent = "Select All";
        } else {
          this.activeFilters.clear();
          uniqueTypes.forEach((type) => this.activeFilters.add(type));
          const allButtons = container.querySelectorAll(".callout-type-selector");
          allButtons.forEach((btn) => btn.addClass("active"));
          toggleButton.textContent = "Clear All";
        }
        this.debouncedRender();
      };
    }
    uniqueTypes.forEach((type) => {
      var _a, _b;
      const button = container.createEl("button", {
        cls: `callout-type-selector callout-filter-${type}`
      });
      const iconName = ((_a = this.plugin.settings.calloutColors[type]) == null ? void 0 : _a.icon) || ((_b = this.plugin.settings.calloutColors["note"]) == null ? void 0 : _b.icon) || "pencil";
      if (iconName && iconName !== "none") {
        const iconEl = button.createEl("span", { cls: "callout-type-icon" });
        if (type === "note" && iconName === "pencil" || iconName === "pencil") {
          iconEl.innerHTML = OBSIDIAN_NOTE_ICON_SVG;
        } else {
          (0, import_obsidian.setIcon)(iconEl, iconName);
        }
        iconEl.style.marginRight = "4px";
        iconEl.style.width = "calc(var(--callout-font-size, 14px) * 16 / 14)";
        iconEl.style.height = "calc(var(--callout-font-size, 14px) * 16 / 14)";
        iconEl.style.display = "inline-flex";
        iconEl.style.alignItems = "center";
      }
      button.createEl("span", {
        text: type.charAt(0).toUpperCase() + type.slice(1),
        cls: "callout-type-text"
      });
      if (this.activeFilters.has(type)) {
        button.addClass("active");
      }
      button.onmousedown = (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (this.activeFilters.has(type)) {
          this.activeFilters.delete(type);
        } else {
          this.activeFilters.add(type);
        }
        if (this.activeFilters.has(type)) {
          button.addClass("active");
        } else {
          button.removeClass("active");
        }
        const toggleButton = container.querySelector(".callout-clear-all-button");
        if (toggleButton) {
          const allSelected = this.activeFilters.size === uniqueTypes.length;
          toggleButton.textContent = allSelected ? "Clear All" : "Select All";
        }
        this.debouncedRender();
      };
    });
  }
  getFilteredCallouts() {
    if (this.activeFilters.size === 0) {
      return [];
    }
    let filtered = this.callouts.filter((callout) => this.activeFilters.has(callout.type));
    if (this.searchQuery.trim()) {
      const query = this.searchQuery.toLowerCase();
      const keywords = query.split(/\s+/).filter((k) => k.length > 0);
      const settings = this.plugin.settings;
      filtered = filtered.filter((callout) => {
        let searchText = "";
        if (this.searchMode === "search") {
          if (settings.searchInFilenames) {
            searchText += callout.file.toLowerCase() + " ";
          }
          if (settings.searchInCalloutTitles) {
            searchText += callout.title.toLowerCase() + " ";
          }
          if (settings.searchInCalloutIds && callout.calloutID) {
            searchText += callout.calloutID.toLowerCase() + " ";
          }
          if (settings.searchInCalloutContent) {
            searchText += callout.content.toLowerCase() + " ";
          }
        } else {
          searchText += callout.file.toLowerCase() + " ";
          if (callout.headers) {
            searchText += callout.headers.join(" ").toLowerCase() + " ";
          }
          searchText += callout.title.toLowerCase() + " ";
          if (callout.calloutID) {
            searchText += callout.calloutID.toLowerCase() + " ";
          }
          searchText += callout.content.toLowerCase() + " ";
        }
        return keywords.every((keyword) => searchText.includes(keyword));
      });
    }
    if (this.searchMode === "search" && filtered.length > this.plugin.settings.maxSearchResults) {
      filtered = filtered.slice(0, this.plugin.settings.maxSearchResults);
    }
    return filtered;
  }
  async renderCalloutsList(container) {
    container.empty();
    const totalCallouts = this.callouts.length;
    const location = this.searchMode === "search" ? "the vault" : "current file";
    const ghostPrompt = container.createEl("div", {
      text: `There are ${totalCallouts} callouts in ${location}`,
      cls: "callout-count-ghost-prompt"
    });
    const filteredCallouts = this.getFilteredCallouts();
    if (filteredCallouts.length === 0) {
      let message = "No callouts found.";
      if (this.activeFilters.size === 0) {
        message = "No callout types selected.";
      } else if (this.searchQuery.trim()) {
        message = `No callouts found matching "${this.searchQuery}".`;
      } else {
        message = "No callouts found for selected types.";
      }
      container.createEl("p", { text: message, cls: "callout-empty-message" });
      return;
    }
    let calloutsToRender;
    if (this.plugin.settings.groupByType) {
      const grouped = this.groupFilteredCallouts(filteredCallouts);
      for (const [type, callouts] of Object.entries(grouped)) {
        container.createEl("h3", {
          text: type.charAt(0).toUpperCase() + type.slice(1) + "s",
          cls: `callout-organizer-type-header callout-organizer-type-header-${type}`
        });
        for (const callout of callouts) {
          await this.renderSingleCallout(container, callout);
        }
      }
    } else {
      calloutsToRender = [...filteredCallouts].sort((a, b) => {
        if (this.searchMode === "search") {
          const aModTime = a.calloutModifyTime || a.fileModTime || "1970-01-01 00:00:00";
          const bModTime = b.calloutModifyTime || b.fileModTime || "1970-01-01 00:00:00";
          return readableToTimestamp(bModTime) - readableToTimestamp(aModTime);
        } else {
          return a.lineNumber - b.lineNumber;
        }
      });
      for (const callout of calloutsToRender) {
        await this.renderSingleCallout(container, callout);
      }
    }
  }
  async renderCallouts(container) {
    const topBar = this.containerEl.querySelector(".callout-top-bar");
    if (topBar) {
      this.setupTopBar(topBar);
    }
    await this.renderCalloutsList(container);
  }
  async renderSingleCallout(container, callout) {
    var _a, _b, _c, _d, _e, _f;
    const calloutEl = container.createEl("div", { cls: "callout-organizer-item" });
    calloutEl.addClass("callout");
    calloutEl.setAttr("data-callout", callout.type);
    if (this.searchMode === "search") {
      calloutEl.addClass("callout-organizer-search-mode");
    }
    calloutEl.style.cursor = "pointer";
    calloutEl.draggable = true;
    calloutEl.onclick = (e) => {
      if (e.target.tagName === "A") {
        return;
      }
      e.preventDefault();
      this.openFile(callout.file, callout.lineNumber, e.ctrlKey || e.metaKey);
    };
    let pendingCalloutId = null;
    calloutEl.ondragstart = (e) => {
      if (e.dataTransfer) {
        let calloutID = callout.calloutID;
        if (!calloutID) {
          calloutID = this.generateCalloutId(callout);
          callout.calloutID = calloutID;
          pendingCalloutId = calloutID;
        }
        const filenameWithExt = callout.file.split("/").pop() || callout.file;
        const filename = filenameWithExt.replace(/\.md$/, "");
        const embedText = `![[${callout.file.replace(/\.md$/, "")}#^${calloutID}]]`;
        e.dataTransfer.setData("text/plain", embedText);
        e.dataTransfer.effectAllowed = "copy";
        calloutEl.style.opacity = "0.5";
      }
    };
    calloutEl.ondragend = () => {
      calloutEl.style.opacity = "1";
      if (pendingCalloutId) {
        setTimeout(async () => {
          try {
            await this.addCalloutIdToCallout(callout, pendingCalloutId);
            await this.plugin.saveCalloutCache(this.callouts);
            pendingCalloutId = null;
          } catch (error) {
            console.error("Error adding callout ID to file:", error);
            callout.calloutID = void 0;
            pendingCalloutId = null;
          }
        }, 100);
      }
    };
    const header = calloutEl.createEl("div", { cls: "callout-organizer-header" });
    header.style.display = "flex";
    header.style.alignItems = "center";
    header.style.gap = "8px";
    const displayTitle = callout.title || callout.type.charAt(0).toUpperCase() + callout.type.slice(1);
    if (displayTitle) {
      const titleEl = header.createEl("span", {
        cls: "callout-organizer-title"
      });
      const calloutColor = ((_a = this.plugin.settings.calloutColors[callout.type]) == null ? void 0 : _a.color) || ((_b = this.plugin.settings.calloutColors["note"]) == null ? void 0 : _b.color) || "var(--callout-title-color)";
      const iconName = ((_c = this.plugin.settings.calloutColors[callout.type]) == null ? void 0 : _c.icon) || ((_d = this.plugin.settings.calloutColors["note"]) == null ? void 0 : _d.icon) || "pencil";
      if (iconName && iconName !== "none") {
        const iconEl = titleEl.createEl("span", { cls: "callout-title-icon" });
        if (callout.type === "note" && iconName === "pencil" || iconName === "pencil") {
          iconEl.innerHTML = OBSIDIAN_NOTE_ICON_SVG;
        } else {
          (0, import_obsidian.setIcon)(iconEl, iconName);
        }
        iconEl.style.marginRight = "6px";
        iconEl.style.width = "calc(var(--callout-font-size, 14px) * 16 / 14)";
        iconEl.style.height = "calc(var(--callout-font-size, 14px) * 16 / 14)";
        iconEl.style.display = "inline-flex";
        iconEl.style.alignItems = "center";
        iconEl.style.color = calloutColor;
      }
      titleEl.style.color = calloutColor;
      import_obsidian.MarkdownRenderer.render(this.app, displayTitle, titleEl, callout.file, this.component).then(() => {
        this.processMathForElement(titleEl);
        titleEl.style.color = calloutColor;
      }).catch((error) => {
        console.warn("Failed to render callout title:", error);
        titleEl.textContent = displayTitle;
        titleEl.style.color = calloutColor;
      });
    }
    {
      const canvasBtn = header.createEl("button", {
        cls: "callout-canvas-button",
        title: "Open in Canvas"
      });
      (0, import_obsidian.setIcon)(canvasBtn, "layout-dashboard");
      canvasBtn.style.marginLeft = "auto";
      canvasBtn.style.padding = "4px";
      canvasBtn.style.border = "none";
      canvasBtn.style.background = "var(--interactive-normal)";
      canvasBtn.style.borderRadius = "4px";
      canvasBtn.style.cursor = "pointer";
      canvasBtn.style.display = "flex";
      canvasBtn.style.alignItems = "center";
      canvasBtn.style.justifyContent = "center";
      canvasBtn.style.width = "24px";
      canvasBtn.style.height = "24px";
      canvasBtn.onmouseover = () => {
        canvasBtn.style.background = "var(--interactive-hover)";
      };
      canvasBtn.onmouseleave = () => {
        canvasBtn.style.background = "var(--interactive-normal)";
      };
      canvasBtn.onclick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.openCalloutCanvas(callout);
      };
    }
    const content = calloutEl.createEl("div", { cls: "callout-organizer-content" });
    import_obsidian.MarkdownRenderer.render(this.app, callout.content, content, callout.file, this.component).then(() => {
      this.processMathForElement(content);
    }).catch((error) => {
      console.warn("Failed to render callout content:", error);
      content.textContent = callout.content;
    });
    const breadcrumb = calloutEl.createEl("div", { cls: "callout-organizer-breadcrumb" });
    if (this.plugin.settings.showFilenames) {
      const fileParts = (_e = callout.file) == null ? void 0 : _e.split("/");
      const filename = ((_f = fileParts == null ? void 0 : fileParts.pop()) == null ? void 0 : _f.replace(/\.md$/, "")) || callout.file || "Unknown";
      const fileLink = breadcrumb.createEl("a", {
        text: filename,
        href: "#",
        cls: "callout-organizer-file-link"
      });
      fileLink.onclick = (e) => {
        e.preventDefault();
        this.openFile(callout.file, callout.lineNumber, e.ctrlKey || e.metaKey);
      };
    }
    if (callout.headers && callout.headers.length > 0) {
      const filteredHeaders = this.filterHeadersBySettings(callout.headers, callout.headerLevels);
      for (const headerTitle of filteredHeaders) {
        if (breadcrumb.children.length > 0) {
          breadcrumb.createEl("span", {
            text: " > ",
            cls: "callout-organizer-breadcrumb-separator"
          });
        }
        const headingLink = breadcrumb.createEl("a", {
          text: headerTitle,
          href: "#",
          cls: "callout-organizer-heading-link"
        });
        headingLink.onclick = (e) => {
          e.preventDefault();
          this.openFile(callout.file, callout.lineNumber, e.ctrlKey || e.metaKey);
        };
      }
    }
    if (callout.calloutID && this.plugin.settings.showCalloutIds) {
      if (breadcrumb.children.length > 0) {
        breadcrumb.createEl("span", {
          text: " > ",
          cls: "callout-organizer-breadcrumb-separator"
        });
      }
      const blockLink = breadcrumb.createEl("a", {
        text: `^${callout.calloutID}`,
        href: "#",
        cls: "callout-organizer-callout-id"
      });
      blockLink.onclick = (e) => {
        e.preventDefault();
        this.openFile(callout.file, callout.lineNumber, e.ctrlKey || e.metaKey);
      };
    }
  }
  groupCallouts() {
    return this.groupFilteredCallouts(this.callouts);
  }
  groupFilteredCallouts(callouts) {
    const grouped = {};
    callouts.forEach((callout) => {
      if (!grouped[callout.type]) {
        grouped[callout.type] = [];
      }
      grouped[callout.type].push(callout);
    });
    Object.keys(grouped).forEach((type) => {
      grouped[type].sort((a, b) => {
        if (this.searchMode === "search") {
          const aModTime = a.calloutModifyTime || a.fileModTime || "1970-01-01 00:00:00";
          const bModTime = b.calloutModifyTime || b.fileModTime || "1970-01-01 00:00:00";
          return readableToTimestamp(bModTime) - readableToTimestamp(aModTime);
        } else {
          return a.lineNumber - b.lineNumber;
        }
      });
    });
    return grouped;
  }
  generateCalloutAlias(_callout, calloutID) {
    return calloutID;
  }
  generateCalloutId(callout) {
    const type = callout.type.toLowerCase();
    const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    let randomChars = "";
    for (let i = 0; i < 6; i++) {
      randomChars += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return `${type}-${randomChars}`;
  }
  async addCalloutIdToCallout(callout, calloutID) {
    try {
      const file = this.app.vault.getAbstractFileByPath(callout.file);
      if (!(file instanceof import_obsidian.TFile)) {
        new import_obsidian.Notice(`File not found: ${callout.file}`);
        return;
      }
      const content = await this.app.vault.read(file);
      if (!content && content !== "") {
        new import_obsidian.Notice(`Failed to read file: ${callout.file}`);
        return;
      }
      const lines = content.split("\n");
      let lastCalloutLineIndex = -1;
      let actualStartLine = -1;
      const expectedLine = callout.lineNumber - 1;
      const searchRange = 10;
      const linesToSearch = [expectedLine];
      for (let i = 1; i <= searchRange; i++) {
        if (expectedLine - i >= 0) {
          linesToSearch.push(expectedLine - i);
        }
      }
      for (let i = 1; i <= searchRange; i++) {
        if (expectedLine + i < lines.length) {
          linesToSearch.push(expectedLine + i);
        }
      }
      for (const lineIndex of linesToSearch) {
        const line = lines[lineIndex];
        const calloutMatch = line.trim().match(/^>\s*\[!([^\]]+)\]\s*(.*)/);
        if (calloutMatch) {
          const foundType = calloutMatch[1];
          const foundTitle = calloutMatch[2].trim();
          if (foundType.toLowerCase() === callout.type.toLowerCase()) {
            if (callout.title && foundTitle) {
              const normalizedCalloutTitle = callout.title.trim().toLowerCase();
              const normalizedFoundTitle = foundTitle.trim().toLowerCase();
              if (normalizedCalloutTitle === normalizedFoundTitle || normalizedCalloutTitle.includes(normalizedFoundTitle) || normalizedFoundTitle.includes(normalizedCalloutTitle)) {
                actualStartLine = lineIndex;
                lastCalloutLineIndex = lineIndex;
                break;
              }
            } else {
              actualStartLine = lineIndex;
              lastCalloutLineIndex = lineIndex;
              break;
            }
          }
        }
      }
      if (actualStartLine >= 0) {
        for (let i = actualStartLine + 1; i < lines.length; i++) {
          const line = lines[i];
          if (line.startsWith(">")) {
            const newCalloutMatch = line.trim().match(/^>\s*\[!([^\]]+)\]/);
            if (newCalloutMatch) {
              break;
            } else {
              lastCalloutLineIndex = i;
            }
          } else {
            break;
          }
        }
      }
      if (lastCalloutLineIndex >= 0) {
        let hasBlockId = false;
        for (let i = actualStartLine; i <= lastCalloutLineIndex; i++) {
          if (lines[i] && lines[i].match(/>\s*\^[\w-]+/)) {
            hasBlockId = true;
            break;
          }
        }
        if (!hasBlockId) {
          lines.splice(lastCalloutLineIndex + 1, 0, `> ^${calloutID}`);
          if (lastCalloutLineIndex + 2 < lines.length && lines[lastCalloutLineIndex + 2].trim() !== "") {
            lines.splice(lastCalloutLineIndex + 2, 0, "");
          } else if (lastCalloutLineIndex + 2 >= lines.length) {
            lines.push("");
          }
          await this.app.vault.modify(file, lines.join("\n"));
          callout.calloutID = calloutID;
        }
      }
    } catch (error) {
      console.error("Error adding callout ID to callout:", error);
      new import_obsidian.Notice("Failed to add callout ID to callout");
    }
  }
  async openFile(filename, lineNumber, newTab) {
    const file = this.app.vault.getAbstractFileByPath(filename);
    if (file instanceof import_obsidian.TFile) {
      let leaf;
      if (newTab) {
        leaf = this.app.workspace.getLeaf("tab");
      } else {
        leaf = this.app.workspace.getLeaf(false);
      }
      await leaf.openFile(file);
      if (lineNumber) {
        const view = leaf.view;
        if (view && "editor" in view) {
          const editor = view.editor;
          if (editor) {
            editor.setCursor(lineNumber - 1, 0);
            editor.scrollIntoView({ from: { line: lineNumber - 1, ch: 0 }, to: { line: lineNumber - 1, ch: 0 } }, true);
            setTimeout(() => {
              this.highlightLine(editor, lineNumber - 1);
            }, 100);
          }
        }
      }
    }
  }
  async openCalloutCanvas(callout) {
    try {
      if (!callout.calloutID) {
        const newCalloutID = this.generateCalloutId(callout);
        callout.calloutID = newCalloutID;
        try {
          await this.addCalloutIdToCallout(callout, newCalloutID);
          await this.plugin.saveCalloutCache(this.callouts);
        } catch (error) {
          console.error("Error adding callout ID to file:", error);
          callout.calloutID = void 0;
          return;
        }
      }
      await this.plugin.createCalloutGraphCanvas(callout);
    } catch (error) {
      console.error("Error opening callout canvas:", error);
    }
  }
  highlightLine(editor, lineNumber) {
    try {
      if (!editor || typeof editor !== "object" || !("lineInfo" in editor)) {
        return;
      }
      const lineInfo = editor.lineInfo(lineNumber);
      if (!lineInfo)
        return;
      const markEl = document.createElement("div");
      markEl.className = "callout-organizer-highlight";
      markEl.style.cssText = `
                position: absolute;
                left: 0;
                right: 0;
                background-color: var(--text-selection);
                opacity: 0.7;
                pointer-events: none;
                animation: callout-highlight-pulse 3s ease-out;
                z-index: 1;
            `;
      if (!document.getElementById("callout-organizer-highlight-style")) {
        const style = document.createElement("style");
        style.id = "callout-organizer-highlight-style";
        style.textContent = `
                @keyframes callout-highlight-pulse {
                    0% { opacity: 0.8; transform: scale(1.02); }
                    50% { opacity: 0.5; }
                    100% { opacity: 0; transform: scale(1); }
                }
                .callout-organizer-highlight {
                    border-radius: 3px;
                }
                `;
        document.head.appendChild(style);
      }
      const editorWithDisplay = editor;
      if (editorWithDisplay.display && editorWithDisplay.display.lineDiv && editorWithDisplay.display.lineDiv.children) {
        const lineEl = editorWithDisplay.display.lineDiv.children[lineNumber];
        if (lineEl && markEl) {
          lineEl.style.position = "relative";
          lineEl.appendChild(markEl);
          setTimeout(() => {
            if (markEl && markEl.parentNode) {
              markEl.parentNode.removeChild(markEl);
            }
          }, 3e3);
        }
      }
    } catch (error) {
      console.warn("Failed to highlight line:", error);
    }
  }
  // Performance optimization methods
  debouncedSearch() {
    if (this.searchDebounceTimer) {
      clearTimeout(this.searchDebounceTimer);
    }
    const delay = this.callouts.length > 100 ? this.SEARCH_DEBOUNCE_DELAY * 2 : this.SEARCH_DEBOUNCE_DELAY;
    this.searchDebounceTimer = setTimeout(() => {
      this.searchDebounceTimer = null;
      const calloutContainer = this.calloutContainerElement || this.containerEl.querySelector(".callout-container");
      if (calloutContainer) {
        this.renderCalloutsList(calloutContainer);
      }
    }, delay);
  }
  debouncedRender() {
    const now = Date.now();
    if (now - this.lastRenderTime < this.MIN_RENDER_INTERVAL) {
      return;
    }
    this.lastRenderTime = now;
    const calloutContainer = this.containerEl.querySelector(".callout-container");
    if (calloutContainer) {
      this.renderCalloutsList(calloutContainer);
    }
  }
  processMathForElement(element) {
    try {
      const mathJax = window.MathJax;
      if (mathJax == null ? void 0 : mathJax.typesetPromise) {
        const mathElements = element.querySelectorAll(".math, mjx-container, [data-math], .cm-math");
        if (mathElements.length > 0) {
          mathJax.typesetPromise([element]).then(() => {
            element.querySelectorAll("mjx-container").forEach((mjx) => {
              const mjxElement = mjx;
              if (mjxElement.getAttribute("display") === "true") {
                mjxElement.style.display = "block";
                mjxElement.style.textAlign = "center";
                mjxElement.style.margin = "1em 0";
              } else {
                mjxElement.style.display = "inline";
                mjxElement.style.margin = "0";
              }
            });
          }).catch(() => {
          });
        }
      }
    } catch (error) {
      console.warn("Math processing error:", error);
    }
  }
  async onClose() {
    var _a;
    if (this.refreshDebounceTimer) {
      clearTimeout(this.refreshDebounceTimer);
      this.refreshDebounceTimer = null;
    }
    if (this.searchDebounceTimer) {
      clearTimeout(this.searchDebounceTimer);
      this.searchDebounceTimer = null;
    }
    this.cachedTypeSelectorContainer = null;
    this.topBarElement = null;
    this.calloutContainerElement = null;
    this.callouts = [];
    this.activeFilters.clear();
    (_a = this.component) == null ? void 0 : _a.unload();
  }
};
var _CalloutOrganizerPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.cacheOperationLock = null;
    this.styleElement = null;
    this.originalErrorHandler = null;
  }
  /**
   * Setup ResizeObserver error handler to suppress loop warnings
   */
  setupResizeObserverErrorHandler() {
    this.originalErrorHandler = window.onerror;
    window.onerror = (message, source, lineno, colno, error) => {
      if (typeof message === "string" && message.includes("ResizeObserver loop completed with undelivered notifications")) {
        return true;
      }
      if (this.originalErrorHandler) {
        return this.originalErrorHandler(message, source, lineno, colno, error);
      }
      return false;
    };
  }
  async onload() {
    await this.loadSettings();
    this.setupResizeObserverErrorHandler();
    this.registerView(
      VIEW_TYPE_CALLOUT_ORGANIZER,
      (leaf) => new CalloutOrganizerView(leaf, this, "current")
    );
    this.registerDomEvent(document, "drop", this.handleCanvasDrop.bind(this), true);
    this.addRibbonIcon("album", "Open Callout Organizer", () => {
      this.activateCalloutOrganizer();
    });
    this.addCommand({
      id: "open-callout-organizer",
      name: "Open Callout Organizer",
      callback: () => {
        this.activateCalloutOrganizer();
      }
    });
    this.addSettingTab(new CalloutOrganizerSettingTab(this.app, this));
    await this.initializeCalloutColors();
    this.injectCustomCalloutCSS();
  }
  async initializeCalloutColors() {
    try {
      const vaultTypes = await this.getAllCalloutTypesInVault();
      const cachedTypes = await this.getAllCalloutTypesFromCache();
      const detectedTypes = /* @__PURE__ */ new Set([...vaultTypes, ...cachedTypes]);
      let settingsChanged = false;
      for (const type of detectedTypes) {
        if (!this.settings.calloutColors[type]) {
          if (this.isBuiltinCalloutType(type)) {
            const obsidianColor = this.getObsidianCalloutColor(type);
            this.settings.calloutColors[type] = {
              color: obsidianColor,
              icon: this.getDefaultIconForCalloutType(type)
            };
          } else {
            this.settings.calloutColors[type] = {
              color: this.getDefaultColorForCalloutType(type),
              icon: this.getDefaultIconForCalloutType(type)
            };
          }
          settingsChanged = true;
        } else if (!this.settings.calloutColors[type].icon) {
          this.settings.calloutColors[type].icon = this.getDefaultIconForCalloutType(type);
          settingsChanged = true;
        }
      }
      if (settingsChanged) {
        await this.saveSettings();
        this.injectCustomCalloutCSS();
      }
    } catch (error) {
      console.error("Error initializing callout colors:", error);
    }
  }
  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (result) {
      return `${parseInt(result[1], 16)},${parseInt(result[2], 16)},${parseInt(result[3], 16)}`;
    }
    return "0,0,0";
  }
  // Get callout types from cached JSON data
  async getAllCalloutTypesFromCache() {
    const calloutTypes = /* @__PURE__ */ new Set();
    const cache = await this.loadCalloutCache();
    if (cache && cache.callouts) {
      for (const callout of cache.callouts) {
        calloutTypes.add(callout.type.toLowerCase().trim());
      }
    } else {
    }
    return calloutTypes;
  }
  async getAllCalloutTypesInVault() {
    const calloutTypes = /* @__PURE__ */ new Set();
    const files = this.app.vault.getMarkdownFiles();
    const calloutRegex = /^>\s*\[!([^\]]+)\]/gm;
    for (const file of files) {
      if (this.shouldSkipFile(file.path, true))
        continue;
      try {
        const content = await this.app.vault.read(file);
        let match;
        let iterations = 0;
        const MAX_ITERATIONS = 1e3;
        calloutRegex.lastIndex = 0;
        while ((match = calloutRegex.exec(content)) !== null && iterations < MAX_ITERATIONS) {
          const type = match[1].toLowerCase().trim();
          calloutTypes.add(type);
          iterations++;
          if (match.index === calloutRegex.lastIndex) {
            calloutRegex.lastIndex++;
          }
        }
      } catch (error) {
        console.warn(`Failed to read file ${file.path} for callout scanning:`, error);
        continue;
      }
    }
    return calloutTypes;
  }
  isBuiltinCalloutType(type) {
    const builtinTypes = /* @__PURE__ */ new Set([
      // Blue family
      "note",
      "info",
      "todo",
      // Teal family
      "abstract",
      "summary",
      "tldr",
      "tip",
      "hint",
      "important",
      // Green family
      "success",
      "check",
      "done",
      // Orange family  
      "question",
      "help",
      "faq",
      "warning",
      "caution",
      "attention",
      // Red family
      "failure",
      "fail",
      "missing",
      "danger",
      "error",
      "bug",
      // Purple family
      "example",
      // Gray family
      "quote",
      "cite"
    ]);
    return builtinTypes.has(type.toLowerCase());
  }
  getDefaultColorForCalloutType(type) {
    const builtinColors = {
      // Blue family
      "note": "#086DDD",
      "info": "#086DDD",
      "todo": "#086DDD",
      // Teal family  
      "abstract": "#00BFBC",
      "summary": "#00BFBC",
      "tldr": "#00BFBC",
      "tip": "#00BFBC",
      "hint": "#00BFBC",
      "important": "#00BFBC",
      // Green family
      "success": "#08B94E",
      "check": "#08B94E",
      "done": "#08B94E",
      // Orange family
      "question": "#EC7500",
      "help": "#EC7500",
      "faq": "#EC7500",
      "warning": "#EC7500",
      "caution": "#EC7500",
      "attention": "#EC7500",
      // Red family
      "failure": "#E93147",
      "fail": "#E93147",
      "missing": "#E93147",
      "danger": "#E93147",
      "error": "#E93147",
      "bug": "#E93147",
      // Purple family
      "example": "#7852EE",
      // Gray family
      "quote": "#9E9E9E",
      "cite": "#9E9E9E",
      // Mathematical/Academic callouts (supporting academic workflows)
      "theorem": "#F19837",
      "lemma": "#F5CA00",
      "proposition": "#A28AE5",
      "definition": "#2EA4E5",
      "corollary": "#E56EEE",
      "conjecture": "#FF6699",
      "remark": "#FF6666",
      "exercise": "#FF6699",
      "problem": "#FF6699"
    };
    return builtinColors[type] || "#086DDD";
  }
  getDefaultIconForCalloutType(type) {
    const builtinIcons = {
      // Blue family
      "note": "pencil",
      "info": "info",
      "todo": "check-circle-2",
      // Teal family
      "abstract": "clipboard-list",
      "summary": "clipboard-list",
      "tldr": "clipboard-list",
      "tip": "flame",
      "hint": "flame",
      "important": "flame",
      // Green family
      "success": "check",
      "check": "check",
      "done": "check",
      // Orange family
      "question": "help-circle",
      "help": "help-circle",
      "faq": "help-circle",
      "warning": "alert-triangle",
      "caution": "alert-triangle",
      "attention": "alert-triangle",
      // Red family
      "failure": "x",
      "fail": "x",
      "missing": "x",
      "danger": "zap",
      "error": "zap",
      "bug": "bug",
      // Purple family
      "example": "list",
      // Gray family
      "quote": "quote",
      "cite": "quote",
      // Mathematical/Academic callouts (common in academic vaults)
      "theorem": "zap",
      "lemma": "lightbulb",
      "proposition": "star",
      "definition": "book-open",
      "corollary": "arrow-right",
      "conjecture": "help-circle",
      "remark": "message-circle",
      "exercise": "dumbbell",
      "problem": "puzzle"
    };
    return builtinIcons[type] || "pencil";
  }
  getObsidianCalloutColor(type) {
    var _a;
    const tempCallout = document.createElement("div");
    tempCallout.className = "callout";
    tempCallout.setAttribute("data-callout", type);
    tempCallout.style.position = "absolute";
    tempCallout.style.left = "-9999px";
    tempCallout.style.opacity = "0";
    document.body.appendChild(tempCallout);
    const computedStyle = getComputedStyle(tempCallout);
    const colorValue = computedStyle.getPropertyValue("--callout-color").trim();
    document.body.removeChild(tempCallout);
    if (colorValue && colorValue.includes(",")) {
      const colorParts = colorValue.split(",").map((x) => parseInt(x.trim()));
      if (colorParts.length >= 3 && colorParts.every((x) => !isNaN(x) && x >= 0 && x <= 255)) {
        const [r, g, b] = colorParts;
        return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
      }
    }
    return ((_a = this.settings.calloutColors[type]) == null ? void 0 : _a.color) || "#448aff";
  }
  injectCustomCalloutCSS() {
    if (this.styleElement) {
      this.styleElement.remove();
    }
    this.styleElement = document.createElement("style");
    this.styleElement.id = "callout-organizer-custom-styles";
    let css = "";
    css += `
.callout-organizer-item {
    font-size: ${this.settings.calloutFontSize}px;
    --callout-font-size: ${this.settings.calloutFontSize}px;
}

.callout-organizer-breadcrumb {
    font-size: ${this.settings.breadcrumbFontSize}px;
}

/* Let native callouts in organizer use their natural styling */
.callout-organizer-item.callout {
    /* Minimal override - only set margin for organizer spacing */
    margin: 8px 0;
}`;
    for (const [type, colors] of Object.entries(this.settings.calloutColors)) {
      const rgbColor = this.hexToRgb(colors.color);
      const iconName = colors.icon || "none";
      if (this.isBuiltinCalloutType(type)) {
        const defaultColor = this.getDefaultColorForCalloutType(type);
        const defaultIcon = this.getDefaultIconForCalloutType(type);
        const hasCustomColor = colors.color !== defaultColor;
        const hasCustomIcon = colors.icon !== defaultIcon;
        if (hasCustomColor || hasCustomIcon) {
          css += `
/* User customized built-in callout: ${type} */
.callout[data-callout="${type}"].callout,
.callout-organizer-item.callout[data-callout="${type}"] {`;
          if (hasCustomColor) {
            css += `
    --callout-color: ${rgbColor} !important;
    --callout-border-color: ${rgbColor} !important;
    --callout-title-color: ${rgbColor} !important;`;
          }
          if (hasCustomIcon) {
            css += `
    --callout-icon: ${iconName === "none" ? "none" : `lucide-${iconName}`} !important;`;
          }
          css += `
}`;
        }
        css += `
.callout-filter-${type}.active {
    background: rgba(${rgbColor}, 0.2);
    border-color: rgb(${rgbColor});
    color: rgb(${rgbColor});
}`;
      } else {
        css += `
/* Custom callout styling for ${type} */
.callout[data-callout="${type}"].callout,
.callout-organizer-item.callout[data-callout="${type}"] {
    --callout-color: ${rgbColor} !important;
    --callout-border-color: ${rgbColor} !important;
    --callout-title-color: ${rgbColor} !important;
    --callout-icon: ${iconName === "none" ? "none" : `lucide-${iconName}`} !important;
}

.callout-filter-${type}.active {
    background: rgba(${rgbColor}, 0.2);
    border-color: rgb(${rgbColor});
    color: rgb(${rgbColor});
}`;
      }
    }
    if (this.settings.customCalloutCSS) {
      css += `
/* Custom Callout CSS - Global */
.callout {
    ${this.settings.customCalloutCSS}
}`;
    }
    if (this.settings.invisibleEmbeddings) {
      css += `
/* Invisible Embeddings */
.markdown-embed {
    padding: 0;
    border: 0;
}`;
    }
    this.styleElement.textContent = css;
    document.head.appendChild(this.styleElement);
  }
  generateCalloutId(callout) {
    const type = callout.type.toLowerCase();
    const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    let randomChars = "";
    for (let i = 0; i < 6; i++) {
      randomChars += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return `${type}-${randomChars}`;
  }
  async addCalloutIdToCallout(callout, calloutID) {
    try {
      const file = this.app.vault.getAbstractFileByPath(callout.file);
      if (!(file instanceof import_obsidian.TFile)) {
        new import_obsidian.Notice(`File not found: ${callout.file}`);
        return;
      }
      const content = await this.app.vault.read(file);
      if (!content && content !== "") {
        new import_obsidian.Notice(`Failed to read file: ${callout.file}`);
        return;
      }
      const lines = content.split("\n");
      let calloutStartLine = -1;
      let calloutEndLine = -1;
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const calloutMatch = line.match(/^>\s*\[!([^\]]+)\]/);
        if (calloutMatch) {
          const foundType = calloutMatch[1].toLowerCase();
          if (foundType === callout.type.toLowerCase()) {
            let currentCalloutContent = "";
            let currentCalloutEndLine = i;
            for (let j = i; j < lines.length; j++) {
              if (lines[j].startsWith(">")) {
                const contentLine = lines[j].substring(1).trim();
                if (contentLine && !contentLine.startsWith("[!") && !contentLine.startsWith("^")) {
                  currentCalloutContent += contentLine + " ";
                }
                currentCalloutEndLine = j;
              } else {
                break;
              }
            }
            currentCalloutContent = currentCalloutContent.trim();
            const expectedContent = callout.content.replace(/\s+/g, " ").trim();
            if (currentCalloutContent === expectedContent || currentCalloutContent.includes(expectedContent.substring(0, Math.min(50, expectedContent.length)))) {
              calloutStartLine = i;
              calloutEndLine = currentCalloutEndLine;
              break;
            }
          }
        }
      }
      if (calloutStartLine === -1) {
        console.warn(`Could not find matching callout for type "${callout.type}" in ${callout.file}`);
        return;
      }
      let hasExistingId = false;
      for (let i = calloutStartLine; i <= calloutEndLine; i++) {
        if (lines[i] && lines[i].match(/^>\s*\^/)) {
          hasExistingId = true;
          break;
        }
      }
      if (!hasExistingId) {
        for (let i = calloutEndLine + 1; i < Math.min(calloutEndLine + 3, lines.length); i++) {
          if (lines[i] && lines[i].startsWith("^")) {
            hasExistingId = true;
            break;
          }
        }
      }
      if (hasExistingId) {
        console.log(`Callout already has an ID, skipping: ${callout.file}`);
        return;
      }
      let lastContentLine = calloutEndLine;
      while (lastContentLine >= calloutStartLine && lines[lastContentLine].trim() === ">") {
        lastContentLine--;
      }
      const insertIndex = lastContentLine + 1;
      lines.splice(insertIndex, 0, `> ^${calloutID}`);
      const newContent = lines.join("\n");
      await this.app.vault.modify(file, newContent);
      callout.calloutID = calloutID;
    } catch (error) {
      console.error("Error adding callout ID:", error);
      new import_obsidian.Notice(`Failed to add ID to callout in ${callout.file}`);
    }
  }
  async activateCalloutOrganizer() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_CALLOUT_ORGANIZER);
    const rightLeaf = this.app.workspace.getLeaf("split", "vertical");
    if (rightLeaf) {
      await rightLeaf.setViewState({
        type: VIEW_TYPE_CALLOUT_ORGANIZER,
        active: true
      });
      const view = rightLeaf.view;
      if (view) {
        view.searchMode = "current";
      }
    }
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CALLOUT_ORGANIZER);
    if (leaves.length > 0) {
      this.app.workspace.revealLeaf(leaves[0]);
    }
  }
  async createCalloutGraphCanvas(selectedCallout) {
    var _a, _b;
    try {
      const sourceFilename = ((_b = (_a = selectedCallout.file) == null ? void 0 : _a.split("/").pop()) == null ? void 0 : _b.replace(".md", "")) || "unknown";
      const canvasFileName = `callout_${sourceFilename}_${selectedCallout.calloutID || Date.now()}.canvas`;
      const canvasPath = `${this.settings.canvasStorageFolder}/${canvasFileName}`;
      const canvasFolder = this.app.vault.getAbstractFileByPath(this.settings.canvasStorageFolder);
      if (!canvasFolder) {
        await this.app.vault.createFolder(this.settings.canvasStorageFolder);
      }
      const mainNodeId = `node-${Date.now()}-main`;
      const mainNodeWidth = selectedCallout.canvasWidth || 400;
      const mainNodeHeight = selectedCallout.canvasHeight || 200;
      const canvasData = {
        nodes: [
          {
            id: mainNodeId,
            type: "file",
            file: selectedCallout.file,
            subpath: `#^${selectedCallout.calloutID}`,
            x: 0,
            y: 0,
            width: mainNodeWidth,
            height: mainNodeHeight,
            color: this.getCanvasColorForCallout(selectedCallout.type)
          }
        ],
        edges: []
      };
      const cache = await this.loadCalloutCache();
      const allCallouts = (cache == null ? void 0 : cache.callouts) || [];
      const getCalloutKey = (callout) => `${callout.file}:${callout.calloutID}`;
      const _mainCalloutKey = getCalloutKey(selectedCallout);
      const calloutMap = /* @__PURE__ */ new Map();
      allCallouts.forEach((callout) => {
        if (callout.calloutID) {
          const key = `${callout.file}:${callout.calloutID}`;
          calloutMap.set(key, callout);
        }
      });
      const directInlinks = [];
      const directOutlinks = [];
      const bidirectionalLinks = [];
      const globalEdgeLabels = /* @__PURE__ */ new Map();
      allCallouts.forEach((callout) => {
        if (callout.outlinks) {
          callout.outlinks.forEach(([filename, calloutID, label]) => {
            if (label) {
              const fromKey = `${callout.file}:${callout.calloutID}`;
              const toKey = `${filename}:${calloutID}`;
              const edgeKey = `${fromKey}->${toKey}`;
              globalEdgeLabels.set(edgeKey, label);
            }
          });
        }
      });
      const outlinkLabels = /* @__PURE__ */ new Map();
      if (selectedCallout.outlinks) {
        selectedCallout.outlinks.forEach(([filename, calloutID, label]) => {
          var _a2;
          const targetKey = `${filename}:${calloutID}`;
          if (label) {
            outlinkLabels.set(targetKey, label);
          }
          const isSelfConnection = filename === selectedCallout.file && calloutID === selectedCallout.calloutID;
          if (isSelfConnection) {
          } else {
            const targetCallout = calloutMap.get(targetKey);
            if (targetCallout) {
              const isTargetLinkingBack = (_a2 = targetCallout.outlinks) == null ? void 0 : _a2.some(
                ([f, cId]) => f === selectedCallout.file && cId === selectedCallout.calloutID
              );
              if (isTargetLinkingBack) {
                bidirectionalLinks.push(targetCallout);
              } else {
                directOutlinks.push(targetCallout);
              }
            }
          }
        });
      }
      allCallouts.forEach((callout) => {
        if (callout.calloutID && callout.outlinks) {
          const hasLinkToMain = callout.outlinks.some(
            ([filename, calloutID]) => filename === selectedCallout.file && calloutID === selectedCallout.calloutID
          );
          if (hasLinkToMain) {
            const calloutKey = getCalloutKey(callout);
            const isSelfConnection = calloutKey === getCalloutKey(selectedCallout);
            if (!isSelfConnection) {
              const alreadyProcessed = bidirectionalLinks.some(
                (biCallout) => getCalloutKey(biCallout) === calloutKey
              );
              if (!alreadyProcessed) {
                directInlinks.push(callout);
              }
            }
          }
        }
      });
      const layoutData = /* @__PURE__ */ new Map();
      const nodeSpacing = 280;
      const levelSpacing = Math.max(600, mainNodeWidth + 200);
      const bidirectionalSpacing = 150;
      directInlinks.forEach((callout, index) => {
        const calloutKey = getCalloutKey(callout);
        const totalInlinks = directInlinks.length;
        const x = -levelSpacing;
        const y = (index - (totalInlinks - 1) / 2) * nodeSpacing;
        layoutData.set(calloutKey, {
          callout,
          x,
          y,
          level: 1,
          side: "left"
        });
      });
      directOutlinks.forEach((callout, index) => {
        const calloutKey = getCalloutKey(callout);
        const totalOutlinks = directOutlinks.length;
        const x = levelSpacing;
        const y = (index - (totalOutlinks - 1) / 2) * nodeSpacing;
        layoutData.set(calloutKey, {
          callout,
          x,
          y,
          level: 1,
          side: "right"
        });
      });
      bidirectionalLinks.forEach((callout, index) => {
        const calloutKey = getCalloutKey(callout);
        const totalBidirectional = bidirectionalLinks.length;
        const x = 0;
        const y = (index - (totalBidirectional - 1) / 2) * bidirectionalSpacing + (index % 2 === 0 ? -250 : 250);
        layoutData.set(calloutKey, {
          callout,
          x,
          y,
          level: 1,
          side: "bidirectional"
        });
      });
      let nodeIdCounter = 0;
      layoutData.forEach(({ callout, x, y, level }) => {
        const defaultWidth = Math.max(300, 400 - level * 25);
        const defaultHeight = Math.max(120, 200 - level * 20);
        const nodeWidth = callout.canvasWidth || defaultWidth;
        const nodeHeight = callout.canvasHeight || defaultHeight;
        const nodeId = `node-${Date.now()}-${++nodeIdCounter}`;
        canvasData.nodes.push({
          id: nodeId,
          type: "file",
          file: callout.file,
          subpath: `#^${callout.calloutID}`,
          x: Math.round(x),
          y: Math.round(y),
          width: nodeWidth,
          height: nodeHeight,
          color: this.getCanvasColorForCallout(callout.type)
        });
      });
      let edgeId = 0;
      const nodeMap = /* @__PURE__ */ new Map();
      canvasData.nodes.forEach((node) => {
        if (node.type === "file" && node.file && node.subpath) {
          const fileMatch = node.subpath.match(/^#\^(.+)$/);
          if (fileMatch) {
            const calloutID = fileMatch[1];
            const key = `${node.file}:${calloutID}`;
            nodeMap.set(key, node);
          }
        }
      });
      const mainNodeKey = `${selectedCallout.file}:${selectedCallout.calloutID}`;
      const mainNode = nodeMap.get(mainNodeKey);
      if (mainNode) {
        directInlinks.forEach((callout) => {
          const calloutKey = getCalloutKey(callout);
          const fromNode = nodeMap.get(calloutKey);
          if (fromNode) {
            const edge = {
              id: `edge-${++edgeId}`,
              fromNode: fromNode.id,
              fromSide: "right",
              toNode: mainNode.id,
              toSide: "left"
            };
            const edgeKey = `${calloutKey}->${mainNodeKey}`;
            const label = globalEdgeLabels.get(edgeKey);
            if (label) {
              edge.label = label;
            }
            canvasData.edges.push(edge);
          }
        });
        directOutlinks.forEach((callout) => {
          const calloutKey = getCalloutKey(callout);
          const toNode = nodeMap.get(calloutKey);
          if (toNode) {
            const edge = {
              id: `edge-${++edgeId}`,
              fromNode: mainNode.id,
              fromSide: "right",
              toNode: toNode.id,
              toSide: "left"
            };
            const globalEdgeKey = `${mainNodeKey}->${calloutKey}`;
            const globalLabel = globalEdgeLabels.get(globalEdgeKey);
            const localLabel = outlinkLabels.get(calloutKey);
            const label = globalLabel || localLabel;
            if (label) {
              edge.label = label;
            }
            canvasData.edges.push(edge);
          }
        });
        bidirectionalLinks.forEach((callout) => {
          const calloutKey = getCalloutKey(callout);
          const biNode = nodeMap.get(calloutKey);
          if (biNode) {
            const layoutInfo = layoutData.get(calloutKey);
            const isAbove = layoutInfo && layoutInfo.y < 0;
            const forwardEdge = {
              id: `edge-${++edgeId}`,
              fromNode: mainNode.id,
              fromSide: "right",
              toNode: biNode.id,
              toSide: "right"
            };
            const globalForwardKey = `${mainNodeKey}->${calloutKey}`;
            const globalForwardLabel = globalEdgeLabels.get(globalForwardKey);
            const localForwardLabel = outlinkLabels.get(calloutKey);
            const forwardLabel = globalForwardLabel || localForwardLabel;
            if (forwardLabel) {
              forwardEdge.label = forwardLabel;
            }
            canvasData.edges.push(forwardEdge);
            const reverseEdge = {
              id: `edge-${++edgeId}`,
              fromNode: biNode.id,
              fromSide: "left",
              toNode: mainNode.id,
              toSide: "left"
            };
            const globalReverseKey = `${calloutKey}->${mainNodeKey}`;
            const reverseLabel = globalEdgeLabels.get(globalReverseKey);
            if (reverseLabel) {
              reverseEdge.label = reverseLabel;
            }
            canvasData.edges.push(reverseEdge);
          }
        });
      }
      try {
        let canvasFile = this.app.vault.getAbstractFileByPath(canvasPath);
        if (canvasFile) {
          await this.app.vault.delete(canvasFile);
        }
        const canvasContent = JSON.stringify(canvasData, null, "	");
        canvasFile = await this.app.vault.create(canvasPath, canvasContent);
        if (canvasFile) {
          const leaf = this.app.workspace.getLeaf("tab");
          await leaf.openFile(canvasFile);
        }
      } catch (error) {
        console.error("Error regenerating canvas:", error);
      }
    } catch (error) {
      console.error("Error creating canvas:", error);
    }
  }
  /**
   * 从canvas edges中读取连接关系
   */
  async getCanvasConnections(selectedCallout) {
    var _a, _b;
    const cache = await this.loadCalloutCache();
    const allCallouts = (cache == null ? void 0 : cache.callouts) || [];
    const calloutMap = /* @__PURE__ */ new Map();
    allCallouts.forEach((callout) => {
      if (callout.calloutID) {
        const key = `${callout.file}:${callout.calloutID}`;
        calloutMap.set(key, callout);
      }
    });
    const relatedCallouts = [];
    const connections = /* @__PURE__ */ new Map();
    const getCalloutKey = (callout) => `${callout.file}:${callout.calloutID}`;
    const sourceFilename = ((_b = (_a = selectedCallout.file) == null ? void 0 : _a.split("/").pop()) == null ? void 0 : _b.replace(".md", "")) || "unknown";
    const canvasFileName = `callout_${sourceFilename}_${selectedCallout.calloutID || "center"}.canvas`;
    const canvasPath = `${this.settings.canvasStorageFolder}/${canvasFileName}`;
    try {
      const canvasFile = this.app.vault.getAbstractFileByPath(canvasPath);
      if (canvasFile && canvasFile instanceof import_obsidian.TFile) {
        const canvasContent = await this.app.vault.read(canvasFile);
        const canvasData = JSON.parse(canvasContent);
        const nodeToCallout = /* @__PURE__ */ new Map();
        if (canvasData.nodes) {
          canvasData.nodes.forEach((node) => {
            if (node.type === "file" && node.file && node.subpath) {
              const match = node.subpath.match(/^#\^(.+)$/);
              if (match) {
                const calloutID = match[1];
                const key = `${node.file}:${calloutID}`;
                const callout = calloutMap.get(key);
                if (callout) {
                  nodeToCallout.set(node.id, callout);
                }
              }
            }
          });
        }
        if (canvasData.edges) {
          canvasData.edges.forEach((edge) => {
            const fromCallout = nodeToCallout.get(edge.fromNode);
            const toCallout = nodeToCallout.get(edge.toNode);
            if (fromCallout && toCallout) {
              const fromKey = getCalloutKey(fromCallout);
              const toKey = getCalloutKey(toCallout);
              if (!connections.has(fromKey)) {
                connections.set(fromKey, /* @__PURE__ */ new Set());
              }
              connections.get(fromKey).add(toKey);
              const selectedKey = getCalloutKey(selectedCallout);
              if (fromKey !== selectedKey && !relatedCallouts.some((c) => getCalloutKey(c) === fromKey)) {
                relatedCallouts.push(fromCallout);
              }
              if (toKey !== selectedKey && !relatedCallouts.some((c) => getCalloutKey(c) === toKey)) {
                relatedCallouts.push(toCallout);
              }
            }
          });
        }
      }
    } catch (error) {
      console.error("Error reading canvas file:", error);
      return this.getRelatedCalloutsFromLinks(selectedCallout);
    }
    return { callouts: relatedCallouts, connections };
  }
  // Note: Currently unused but kept for potential future use
  // private async getRelatedCallouts(selectedCallout: CalloutItem): Promise<{callouts: CalloutItem[], connections: Map<string, Set<string>>}> {
  //     // 优先使用canvas连接方式
  //     return this.getCanvasConnections(selectedCallout);
  // }
  async getRelatedCalloutsFromLinks(selectedCallout) {
    const cache = await this.loadCalloutCache();
    const allCallouts = (cache == null ? void 0 : cache.callouts) || [];
    const calloutMap = /* @__PURE__ */ new Map();
    allCallouts.forEach((callout) => {
      if (callout.calloutID) {
        const key = `${callout.file}:${callout.calloutID}`;
        calloutMap.set(key, callout);
      }
    });
    const relatedCallouts = [];
    const addedCalloutKeys = /* @__PURE__ */ new Set();
    const connections = /* @__PURE__ */ new Map();
    const getCalloutKey = (callout) => `${callout.file}:${callout.calloutID}`;
    const discoverAtDepth = (callout, currentDepth, maxDepth, visited = /* @__PURE__ */ new Set()) => {
      const calloutKey = getCalloutKey(callout);
      if (visited.has(calloutKey)) {
        return;
      }
      const pathVisited = new Set(visited);
      pathVisited.add(calloutKey);
      if (currentDepth > 0 && !addedCalloutKeys.has(calloutKey)) {
        relatedCallouts.push(callout);
        addedCalloutKeys.add(calloutKey);
      }
      if (currentDepth >= maxDepth) {
        return;
      }
      if (callout.outlinks) {
        callout.outlinks.forEach(([filename, calloutID]) => {
          const targetKey = `${filename}:${calloutID}`;
          const targetCallout = calloutMap.get(targetKey);
          if (targetCallout) {
            if (!connections.has(calloutKey)) {
              connections.set(calloutKey, /* @__PURE__ */ new Set());
            }
            connections.get(calloutKey).add(targetKey);
            discoverAtDepth(targetCallout, currentDepth + 1, maxDepth, pathVisited);
          }
        });
      }
      allCallouts.forEach((inlinkCallout) => {
        if (inlinkCallout.calloutID && inlinkCallout.outlinks) {
          const hasLinkToCurrent = inlinkCallout.outlinks.some(
            ([filename, calloutID]) => filename === callout.file && calloutID === callout.calloutID
          );
          if (hasLinkToCurrent) {
            const inlinkKey = getCalloutKey(inlinkCallout);
            if (!connections.has(inlinkKey)) {
              connections.set(inlinkKey, /* @__PURE__ */ new Set());
            }
            connections.get(inlinkKey).add(calloutKey);
            discoverAtDepth(inlinkCallout, currentDepth + 1, maxDepth, pathVisited);
          }
        }
      });
    };
    discoverAtDepth(selectedCallout, 0, 999);
    return { callouts: relatedCallouts, connections };
  }
  /**
   * 根据callout类型获取对应的canvas颜色
   */
  getCanvasColorForCallout(calloutType) {
    var _a;
    const calloutColor = (_a = this.settings.calloutColors[calloutType]) == null ? void 0 : _a.color;
    if (!calloutColor) {
      return "#086ddd";
    }
    return calloutColor;
  }
  /**
   * 从canvas文件名中提取对应的callout信息
   * 新规范: callout_filename_calloutid.canvas
   * 例如: callout_CanvasCallouts_example-id.canvas -> { filename: "CanvasCallouts.md", calloutID: "example-id" }
   * 注意：calloutID中不包含下划线，filename可能包含下划线
   */
  extractCalloutFromCanvasName(canvasFileName) {
    if (!canvasFileName.startsWith("callout_") || !canvasFileName.endsWith(".canvas")) {
      return null;
    }
    const withoutPrefixSuffix = canvasFileName.slice(8, -7);
    const lastUnderscoreIndex = withoutPrefixSuffix.lastIndexOf("_");
    if (lastUnderscoreIndex === -1) {
      return null;
    }
    const filename = withoutPrefixSuffix.slice(0, lastUnderscoreIndex);
    const calloutID = withoutPrefixSuffix.slice(lastUnderscoreIndex + 1);
    const filenameWithExt = filename.endsWith(".md") ? filename : `${filename}.md`;
    return { filename: filenameWithExt, calloutID };
  }
  /**
   * 分析canvas文件中的链接关系，只更新outlinks（移除inlinks冗余）
   */
  async analyzeCanvasLinks(callouts) {
    try {
      const updatedCallouts = callouts.map((callout) => ({
        ...callout,
        outlinks: [...callout.outlinks || []]
        // Keep existing outlinks from text content
      }));
      const calloutMap = /* @__PURE__ */ new Map();
      updatedCallouts.forEach((callout) => {
        if (callout.calloutID) {
          const key = `${callout.file}:${callout.calloutID}`;
          calloutMap.set(key, callout);
        }
      });
      const canvasFolder = this.app.vault.getAbstractFileByPath(this.settings.canvasStorageFolder);
      if (!canvasFolder || !(canvasFolder instanceof import_obsidian.TFolder)) {
        return updatedCallouts;
      }
      const canvasFiles = canvasFolder.children.filter(
        (file) => file instanceof import_obsidian.TFile && file.extension === "canvas"
      );
      for (const canvasFile of canvasFiles) {
        try {
          const canvasContent = await this.app.vault.read(canvasFile);
          const canvasData = JSON.parse(canvasContent);
          const targetCallout = this.extractCalloutFromCanvasName(canvasFile.name);
          if (!targetCallout) {
            continue;
          }
          const targetKey = `${targetCallout.filename}:${targetCallout.calloutID}`;
          const targetCalloutItem = calloutMap.get(targetKey);
          if (!targetCalloutItem) {
            continue;
          }
          if (canvasData.edges && Array.isArray(canvasData.edges) && canvasData.nodes && Array.isArray(canvasData.nodes)) {
            const nodeIdToCallout = /* @__PURE__ */ new Map();
            const targetFromNodeIds = [];
            canvasData.nodes.forEach((node) => {
              if (node.type === "text" && node.text) {
                const embedMatch = node.text.match(/!\[\[([^#\]]+)#\^([^\]]+)\]\]/);
                if (embedMatch) {
                  const filename = embedMatch[1];
                  const calloutID = embedMatch[2];
                  nodeIdToCallout.set(node.id, [filename, calloutID]);
                  const targetFilename = targetCallout.filename.replace(/\.md$/, "");
                  if (filename === targetFilename && calloutID === targetCallout.calloutID) {
                    targetFromNodeIds.push(node.id);
                    if (node.width && node.height) {
                      targetCalloutItem.canvasWidth = node.width;
                      targetCalloutItem.canvasHeight = node.height;
                    }
                  }
                } else {
                }
              } else if (node.type === "file" && node.file && node.subpath) {
                const fileMatch = node.subpath.match(/^#\^(.+)$/);
                if (fileMatch) {
                  const filename = node.file.replace(/\.md$/, "");
                  const calloutID = fileMatch[1];
                  nodeIdToCallout.set(node.id, [filename, calloutID]);
                  const targetFilename = targetCallout.filename.replace(/\.md$/, "");
                  if (filename === targetFilename && calloutID === targetCallout.calloutID) {
                    targetFromNodeIds.push(node.id);
                    if (node.width && node.height) {
                      targetCalloutItem.canvasWidth = node.width;
                      targetCalloutItem.canvasHeight = node.height;
                    }
                  }
                }
              }
            });
            if (targetFromNodeIds.length === 0) {
              continue;
            }
            const targetEdges = canvasData.edges.filter((edge) => targetFromNodeIds.includes(edge.fromNode));
            targetEdges.forEach((edge) => {
              const fromNodeId = edge.fromNode;
              const toNodeId = edge.toNode;
              const fromCalloutInfo = nodeIdToCallout.get(fromNodeId);
              const toCalloutInfo = nodeIdToCallout.get(toNodeId);
              if (fromCalloutInfo && toCalloutInfo) {
                const [fromFile, fromCalloutID] = fromCalloutInfo;
                const [toFile, toCalloutID] = toCalloutInfo;
                const fromKeyWithExt = `${fromFile}.md:${fromCalloutID}`;
                const fromCallout = calloutMap.get(fromKeyWithExt);
                if (fromCallout) {
                  fromCallout.outlinks = fromCallout.outlinks || [];
                  const toFileWithExt = `${toFile}.md`;
                  const edgeLabel = edge.label || void 0;
                  const outLinkExists = fromCallout.outlinks.some(([file, id]) => file === toFileWithExt && id === toCalloutID);
                  if (!outLinkExists) {
                    if (edgeLabel) {
                      fromCallout.outlinks.push([toFileWithExt, toCalloutID, edgeLabel]);
                    } else {
                      fromCallout.outlinks.push([toFileWithExt, toCalloutID]);
                    }
                  }
                }
              } else if (fromCalloutInfo) {
                const toNode = canvasData.nodes.find((n) => n.id === toNodeId);
                if (toNode && toNode.type === "text" && toNode.text) {
                  const embedMatch = toNode.text.match(/!\[\[([^#\]]+)#\^([^\]]+)\]\]/);
                  if (embedMatch) {
                    const [fromFile, fromCalloutID] = fromCalloutInfo;
                    const embedFilename = embedMatch[1];
                    const embedCalloutID = embedMatch[2];
                    const fromKeyWithExt = `${fromFile}.md:${fromCalloutID}`;
                    const fromCallout = calloutMap.get(fromKeyWithExt);
                    if (fromCallout) {
                      fromCallout.outlinks = fromCallout.outlinks || [];
                      const embedFileWithExt = embedFilename.endsWith(".md") ? embedFilename : `${embedFilename}.md`;
                      const edgeLabel = edge.label || void 0;
                      const outLinkExists = fromCallout.outlinks.some(([file, id]) => file === embedFileWithExt && id === embedCalloutID);
                      if (!outLinkExists) {
                        if (edgeLabel) {
                          fromCallout.outlinks.push([embedFileWithExt, embedCalloutID, edgeLabel]);
                        } else {
                          fromCallout.outlinks.push([embedFileWithExt, embedCalloutID]);
                        }
                      }
                    }
                  }
                }
              }
            });
          }
        } catch (error) {
          console.warn(`Failed to analyze canvas file ${canvasFile.path}:`, error);
        }
      }
      updatedCallouts.forEach((callout) => {
        if (callout.outlinks && callout.outlinks.length > 0) {
        }
      });
      return updatedCallouts;
    } catch (error) {
      console.error("Error analyzing canvas links:", error);
      return callouts;
    }
  }
  /**
   * Handle canvas drop events to fix node IDs for callout nodes
   */
  handleCanvasDrop(event) {
    const target = event.target;
    const canvasEl = target.closest('.canvas-node-container, .canvas-wrapper, .view-content[data-type="canvas"]');
    if (!canvasEl || !event.dataTransfer)
      return;
    const canvasNodeProps = event.dataTransfer.getData("text/canvas-node-props");
    if (canvasNodeProps) {
      try {
        const props = JSON.parse(canvasNodeProps);
        requestAnimationFrame(() => {
          this.performCanvasOperations(canvasEl, props);
        });
      } catch (error) {
        console.error("Error parsing canvas node props:", error);
      }
    }
  }
  /**
   * Perform canvas operations in a controlled manner to prevent ResizeObserver loops
   */
  async performCanvasOperations(canvasEl, props) {
    try {
      await this.fixCanvasNodeId(canvasEl, props);
      requestAnimationFrame(() => {
        this.removeDuplicateTextNodes(canvasEl, props);
        requestAnimationFrame(() => {
          this.deselectAllCanvasNodes();
        });
      });
    } catch (error) {
      console.error("Error performing canvas operations:", error);
    }
  }
  /**
   * Helper function to deselect all canvas nodes
   */
  deselectAllCanvasNodes() {
    try {
      const activeLeaf = this.app.workspace.getActiveViewOfType("canvas");
      if (!activeLeaf)
        return;
      const canvasView = activeLeaf;
      const canvas = canvasView.canvas;
      if (!canvas)
        return;
      if (canvas.selection && canvas.selection.clear) {
        canvas.selection.clear();
      } else if (canvas.deselectAll) {
        canvas.deselectAll();
      }
      if (canvas.wrapperEl) {
        const focusedElement = canvas.wrapperEl.querySelector(":focus");
        if (focusedElement && typeof focusedElement.blur === "function") {
          focusedElement.blur();
        }
      }
    } catch (error) {
      console.error("Error deselecting canvas nodes:", error);
    }
  }
  /**
   * Fix the canvas node ID after it's been created
   */
  async fixCanvasNodeId(_canvasEl, nodeProps) {
    try {
      const canvasView = this.app.workspace.getActiveViewOfType("canvas");
      if (canvasView) {
        const canvas = canvasView.canvas;
        if (!canvas || !canvas.nodes)
          return;
        if (canvas.nodes.has(nodeProps.id)) {
          return;
        }
        let targetNode = null;
        let oldNodeId = null;
        for (const [nodeId, node] of canvas.nodes) {
          if (node.text === nodeProps.text && nodeId !== nodeProps.id) {
            targetNode = node;
            oldNodeId = nodeId;
            break;
          }
        }
        if (targetNode && oldNodeId && nodeProps.id) {
          const originalId = targetNode.id;
          targetNode.id = nodeProps.id;
          canvas.nodes.delete(originalId);
          canvas.nodes.set(nodeProps.id, targetNode);
          if (canvas.requestSave) {
            canvas.requestSave();
          }
        }
      }
    } catch (error) {
      console.error("Error fixing canvas node ID:", error);
    }
  }
  /**
   * Remove duplicate text nodes that contain embed links matching our file nodes
   */
  async removeDuplicateTextNodes(_canvasEl, nodeProps) {
    try {
      const canvasView = this.app.workspace.getActiveViewOfType("canvas");
      if (canvasView) {
        const canvas = canvasView.canvas;
        if (!canvas || !canvas.nodes)
          return;
        const expectedEmbedText = `![[${nodeProps.file.replace(/\.md$/, "")}${nodeProps.subpath}]]`;
        const nodesToRemove = [];
        let hasMatchingFileNode = false;
        for (const [_nodeId, node] of canvas.nodes) {
          if (node.type === "file" && node.file === nodeProps.file && node.subpath === nodeProps.subpath) {
            hasMatchingFileNode = true;
            break;
          }
        }
        if (hasMatchingFileNode) {
          for (const [_nodeId, node] of canvas.nodes) {
            if (node.type === "text" && node.text && node.text.includes(expectedEmbedText)) {
              nodesToRemove.push(_nodeId);
            }
          }
        }
        for (const nodeId of nodesToRemove) {
          canvas.nodes.delete(nodeId);
        }
        if (nodesToRemove.length > 0) {
          if (canvas.requestSave) {
            canvas.requestSave();
          }
          if (canvas.markDirty) {
            canvas.markDirty();
          }
        }
      }
    } catch (error) {
      console.error("Error removing duplicate text nodes:", error);
    }
  }
  getCalloutView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CALLOUT_ORGANIZER);
    if (leaves.length > 0) {
      return leaves[0].view;
    }
    return null;
  }
  async extractCurrentFileCallouts() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || !activeFile.path.endsWith(".md")) {
      return [];
    }
    const existingCache = await this.loadCalloutCache();
    return await this.extractCalloutsFromFile(activeFile, existingCache);
  }
  async extractAllCallouts() {
    const cache = await this.loadCalloutCache();
    if (cache && await this.isCacheValid(cache)) {
      const sortedCallouts = [...cache.callouts].sort((a, b) => {
        const aModTime = a.calloutModifyTime || a.fileModTime || "1970-01-01 00:00:00";
        const bModTime = b.calloutModifyTime || b.fileModTime || "1970-01-01 00:00:00";
        return readableToTimestamp(bModTime) - readableToTimestamp(aModTime);
      });
      return sortedCallouts;
    }
    const callouts = await this.scanAllCallouts();
    const saveResult = await this.saveCalloutCache(callouts);
    if (saveResult) {
    } else {
    }
    return callouts;
  }
  async scanAllCallouts() {
    const callouts = [];
    const files = this.app.vault.getMarkdownFiles();
    const currentFile = this.app.workspace.getActiveFile();
    const processedFiles = /* @__PURE__ */ new Set();
    const existingCache = await this.loadCalloutCache();
    if (currentFile && currentFile.path.endsWith(".md")) {
      const currentFileCallouts = await this.extractCalloutsFromFile(currentFile, existingCache);
      callouts.push(...currentFileCallouts);
      processedFiles.add(currentFile.path);
    }
    for (const file of files) {
      if (processedFiles.has(file.path) || this.shouldSkipFile(file.path, true))
        continue;
      const fileCallouts = await this.extractCalloutsFromFile(file, existingCache);
      callouts.push(...fileCallouts);
      processedFiles.add(file.path);
    }
    return callouts;
  }
  async refreshAllCallouts() {
    const callouts = await this.scanAllCallouts();
    const calloutsWithLinks = await this.analyzeCanvasLinks(callouts);
    await this.saveCalloutCache(calloutsWithLinks);
    return calloutsWithLinks;
  }
  shouldSkipFile(filePath, searchMode = false) {
    if (!searchMode)
      return false;
    const folders = this.settings.excludedFolders;
    if (folders.length === 0)
      return false;
    return folders.some(
      (folder) => filePath.startsWith(folder + "/") || filePath === folder
    );
  }
  // Create a unique signature for a callout to track its creation time
  createCalloutSignature(filePath, calloutID) {
    if (calloutID) {
      return `${filePath}:${calloutID}`;
    }
    const tempId = `temp-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
    return `${filePath}:${tempId}`;
  }
  async extractCalloutsFromFile(file, existingCache) {
    var _a, _b;
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const callouts = [];
    const fileModTime = file.stat.mtime;
    if (existingCache === void 0) {
      existingCache = await this.loadCalloutCache();
    }
    const headingRegex = _CalloutOrganizerPlugin.HEADING_REGEX;
    const calloutRegex = _CalloutOrganizerPlugin.CALLOUT_REGEX;
    const blockIdRegex = _CalloutOrganizerPlugin.BLOCK_ID_REGEX;
    const allHeaders = [];
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.startsWith("#")) {
        const headingMatch = line.match(headingRegex);
        if (headingMatch) {
          allHeaders.push({
            title: headingMatch[2].trim(),
            level: headingMatch[1].length,
            lineNumber: i + 1
          });
        }
      }
    }
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (!line.startsWith(">"))
        continue;
      const calloutMatch = line.match(calloutRegex);
      if (calloutMatch) {
        const type = calloutMatch[1].toLowerCase();
        const title = calloutMatch[2].trim();
        const contentLines = [];
        let calloutID = "";
        let j = i + 1;
        for (; j < lines.length; j++) {
          const nextLine = lines[j];
          if (nextLine.startsWith(">")) {
            if (nextLine.includes("[!")) {
              const nextCalloutMatch = nextLine.match(calloutRegex);
              if (nextCalloutMatch) {
                break;
              }
            }
            const contentLine = nextLine.replace(/^>\s?/, "");
            const blockMatch = contentLine.match(blockIdRegex);
            if (blockMatch) {
              calloutID = blockMatch[1];
              const cleanContent = contentLine.replace(/\s*\^[\w-]+\s*$/, "");
              if (cleanContent)
                contentLines.push(cleanContent);
            } else {
              contentLines.push(contentLine);
            }
          } else if (nextLine.trim() === "") {
          } else {
            break;
          }
        }
        i = j - 1;
        const currentLineNumber = i + 1;
        const relevantHeaders = allHeaders.filter((header) => header.lineNumber <= currentLineNumber);
        const hierarchy = [];
        for (const heading of relevantHeaders) {
          while (hierarchy.length > 0 && hierarchy[hierarchy.length - 1].level >= heading.level) {
            hierarchy.pop();
          }
          hierarchy.push(heading);
        }
        let calloutSignature;
        if (calloutID) {
          calloutSignature = this.createCalloutSignature(file.path, calloutID);
        } else {
          calloutSignature = `${file.path}:${currentLineNumber}:${type}:${title}`;
        }
        const currentTime = Date.now();
        const currentReadableTime = timestampToReadable(currentTime);
        const fileModTimeReadable = timestampToReadable(fileModTime);
        const preliminaryCallout = {
          file: file.path,
          type,
          title,
          content: contentLines.join("\n").trim(),
          lineNumber: currentLineNumber,
          fileModTime: fileModTimeReadable
        };
        let creationTime;
        let modificationTime;
        if (calloutID) {
          if ((_a = existingCache == null ? void 0 : existingCache.calloutCreationTimes) == null ? void 0 : _a[calloutSignature]) {
            creationTime = existingCache.calloutCreationTimes[calloutSignature];
            const existingCallout = (_b = existingCache.callouts) == null ? void 0 : _b.find(
              (c) => c.calloutID === calloutID && c.file === file.path
            );
            if (existingCallout && hasCalloutChanged(preliminaryCallout, existingCallout)) {
              modificationTime = currentReadableTime;
            } else {
              modificationTime = (existingCallout == null ? void 0 : existingCallout.calloutModifyTime) || currentReadableTime;
            }
          } else {
            creationTime = currentReadableTime;
            modificationTime = currentReadableTime;
          }
        } else {
          creationTime = fileModTimeReadable;
          modificationTime = fileModTimeReadable;
        }
        const calloutItem = {
          file: file.path,
          type,
          title,
          content: contentLines.join("\n").trim(),
          lineNumber: currentLineNumber,
          fileModTime: fileModTimeReadable,
          calloutCreatedTime: creationTime,
          calloutModifyTime: modificationTime
        };
        const outlinks = this.extractOutlinksFromContent(calloutItem.content, file.path, calloutID);
        calloutItem.outlinks = outlinks;
        if (calloutID)
          calloutItem.calloutID = calloutID;
        if (hierarchy.length > 0) {
          calloutItem.headers = hierarchy.map((h) => h.title);
          calloutItem.headerLevels = hierarchy.map((h) => h.level);
        }
        callouts.push(calloutItem);
      }
    }
    return callouts;
  }
  /**
   * Extract outlinks from callout content
   * Looks for patterns like [[#^calloutID]] or [[filename#^calloutID]]
   */
  extractOutlinksFromContent(content, currentFilePath, currentCalloutID) {
    const outlinks = [];
    const linkRegex = /\[\[([^#\]]*)(#\^([^\]]+))?\]\]/g;
    let match;
    let matchCount = 0;
    const MAX_MATCHES = 100;
    linkRegex.lastIndex = 0;
    while ((match = linkRegex.exec(content)) !== null && matchCount < MAX_MATCHES) {
      matchCount++;
      const filename = match[1] || "";
      const calloutID = match[3];
      if (calloutID) {
        let targetFilename;
        if (!filename) {
          targetFilename = currentFilePath;
        } else {
          targetFilename = filename.endsWith(".md") ? filename : `${filename}.md`;
        }
        outlinks.push([targetFilename, calloutID]);
      }
      if (match.index === linkRegex.lastIndex) {
        linkRegex.lastIndex++;
      }
    }
    if (matchCount >= MAX_MATCHES) {
      console.error(`[ERROR] Potential infinite loop detected in extractOutlinksFromContent for ${currentFilePath}#^${currentCalloutID}`);
    }
    return outlinks;
  }
  // Cache management methods
  getCacheFilePath() {
    return `.obsidian/plugins/${_CalloutOrganizerPlugin.PLUGIN_FOLDER}/${_CalloutOrganizerPlugin.CACHE_FILENAME}`;
  }
  async loadCalloutCache() {
    if (this.cacheOperationLock) {
      await this.cacheOperationLock;
    }
    try {
      const cacheFilePath = this.getCacheFilePath();
      const adapter = this.app.vault.adapter;
      const exists = await adapter.exists(cacheFilePath);
      if (!exists) {
        return null;
      }
      const cacheContent = await adapter.read(cacheFilePath);
      let cache;
      try {
        cache = JSON.parse(cacheContent);
        if (!cache || typeof cache !== "object" || !Array.isArray(cache.callouts)) {
          throw new Error("Invalid cache structure");
        }
      } catch (parseError) {
        console.warn("Failed to parse cache file, will regenerate:", parseError);
        return null;
      }
      if (!cache.calloutCreationTimes) {
        cache.calloutCreationTimes = {};
      } else {
        const convertedTimes = {};
        for (const [signature, time] of Object.entries(cache.calloutCreationTimes)) {
          if (typeof time === "number") {
            convertedTimes[signature] = timestampToReadable(time);
          } else {
            convertedTimes[signature] = time;
          }
        }
        cache.calloutCreationTimes = convertedTimes;
      }
      if (cache.fileModTimes) {
        const convertedFileModTimes = {};
        for (const [filePath, time] of Object.entries(cache.fileModTimes)) {
          if (typeof time === "number") {
            convertedFileModTimes[filePath] = timestampToReadable(time);
          } else {
            convertedFileModTimes[filePath] = time;
          }
        }
        cache.fileModTimes = convertedFileModTimes;
      }
      if (cache.callouts) {
        for (const callout of cache.callouts) {
          if (callout.fileModTime && typeof callout.fileModTime === "number") {
            callout.fileModTime = timestampToReadable(callout.fileModTime);
          }
          if (callout.calloutCreatedTime && typeof callout.calloutCreatedTime === "number") {
            callout.calloutCreatedTime = timestampToReadable(callout.calloutCreatedTime);
          }
          if (callout.calloutModifyTime && typeof callout.calloutModifyTime === "number") {
            callout.calloutModifyTime = timestampToReadable(callout.calloutModifyTime);
          }
        }
      }
      if (cache.version !== _CalloutOrganizerPlugin.CACHE_VERSION) {
        return null;
      }
      const currentVaultPath = this.app.vault.getName() || "";
      if (cache.vaultPath !== currentVaultPath) {
        return null;
      }
      return cache;
    } catch (error) {
      console.warn("Failed to load callout cache:", error);
      return null;
    }
  }
  async saveCalloutCache(callouts) {
    const saveOperation = async () => {
      try {
        const fileModTimes = {};
        const files = this.app.vault.getMarkdownFiles();
        for (const file of files) {
          if (!this.shouldSkipFile(file.path, true)) {
            fileModTimes[file.path] = timestampToReadable(file.stat.mtime);
          }
        }
        const calloutCreationTimes = {};
        for (const callout of callouts) {
          if (callout.calloutCreatedTime) {
            let signature;
            if (callout.calloutID) {
              signature = this.createCalloutSignature(callout.file, callout.calloutID);
            } else {
              signature = `${callout.file}:${callout.lineNumber}:${callout.type}:${callout.title}`;
            }
            calloutCreationTimes[signature] = callout.calloutCreatedTime;
          }
        }
        const cache = {
          version: _CalloutOrganizerPlugin.CACHE_VERSION,
          timestamp: Date.now(),
          vaultPath: this.app.vault.getName() || "",
          callouts,
          fileModTimes,
          calloutCreationTimes
        };
        const cacheFilePath = this.getCacheFilePath();
        const cacheContent = JSON.stringify(cache, null, 2);
        const adapter = this.app.vault.adapter;
        const pluginDir = `.obsidian/plugins/${_CalloutOrganizerPlugin.PLUGIN_FOLDER}`;
        if (!await adapter.exists(pluginDir)) {
          await adapter.mkdir(pluginDir);
        }
        await adapter.write(cacheFilePath, cacheContent);
        return true;
      } catch (error) {
        console.error("Failed to save callout cache:", error);
        return false;
      }
    };
    this.cacheOperationLock = saveOperation();
    const result = await this.cacheOperationLock;
    this.cacheOperationLock = null;
    return result;
  }
  async isCacheValid(cache) {
    if (!cache) {
      return false;
    }
    try {
      for (const [filePath, cachedModTime] of Object.entries(cache.fileModTimes)) {
        const file = this.app.vault.getAbstractFileByPath(filePath);
        if (file instanceof import_obsidian.TFile) {
          if (file.stat.mtime > readableToTimestamp(cachedModTime)) {
            return false;
          }
        } else {
          return false;
        }
      }
      const currentFiles = this.app.vault.getMarkdownFiles();
      for (const file of currentFiles) {
        if (!this.shouldSkipFile(file.path, true) && !cache.fileModTimes.hasOwnProperty(file.path)) {
          return false;
        }
      }
      return true;
    } catch (error) {
      console.warn("Error validating cache:", error);
      return false;
    }
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_CALLOUT_ORGANIZER);
    if (this.originalErrorHandler !== null) {
      window.onerror = this.originalErrorHandler;
    }
    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
    const highlightStyle = document.getElementById("callout-organizer-highlight-style");
    if (highlightStyle) {
      highlightStyle.remove();
    }
    const highlights = document.querySelectorAll(".callout-organizer-highlight");
    highlights.forEach((el) => el.remove());
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var CalloutOrganizerPlugin = _CalloutOrganizerPlugin;
// Static regex patterns for better performance
CalloutOrganizerPlugin.HEADING_REGEX = /^(#{1,6})\s+(.+)$/;
CalloutOrganizerPlugin.CALLOUT_REGEX = /^>\s*\[!([^\]]+)\]\s*(.*?)$/;
CalloutOrganizerPlugin.BLOCK_ID_REGEX = /\^([\w-]+)\s*$/;
CalloutOrganizerPlugin.CONTENT_EXTRACT_REGEX = /^>\s?/;
// Cache constants
CalloutOrganizerPlugin.CACHE_VERSION = "1.4";
CalloutOrganizerPlugin.PLUGIN_FOLDER = "callout-organizer";
CalloutOrganizerPlugin.CACHE_FILENAME = "callouts.json";
var CalloutOrganizerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Callout Organizer Settings" });
    containerEl.createEl("h3", { text: "Display Options" });
    const displayContainer = containerEl.createEl("div", { cls: "callout-settings-indent" });
    new import_obsidian.Setting(displayContainer).setName("Show Filenames").setDesc("Display filenames in the breadcrumb navigation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showFilenames).onChange(async (value) => {
      this.plugin.settings.showFilenames = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Show H1 Headers").setDesc("Display H1 headers (# Header) in the breadcrumb navigation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showH1Headers).onChange(async (value) => {
      this.plugin.settings.showH1Headers = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Show H2 Headers").setDesc("Display H2 headers (## Header) in the breadcrumb navigation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showH2Headers).onChange(async (value) => {
      this.plugin.settings.showH2Headers = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Show H3 Headers").setDesc("Display H3 headers (### Header) in the breadcrumb navigation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showH3Headers).onChange(async (value) => {
      this.plugin.settings.showH3Headers = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Show H4 Headers").setDesc("Display H4 headers (#### Header) in the breadcrumb navigation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showH4Headers).onChange(async (value) => {
      this.plugin.settings.showH4Headers = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Show H5 Headers").setDesc("Display H5 headers (##### Header) in the breadcrumb navigation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showH5Headers).onChange(async (value) => {
      this.plugin.settings.showH5Headers = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Show H6 Headers").setDesc("Display H6 headers (###### Header) in the breadcrumb navigation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showH6Headers).onChange(async (value) => {
      this.plugin.settings.showH6Headers = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Show Callout IDs").setDesc("Display callout block IDs (^callout-id) in the breadcrumb navigation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showCalloutIds).onChange(async (value) => {
      this.plugin.settings.showCalloutIds = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Callout Font Size").setDesc("Font size for callout content in pixels").addText((text) => text.setPlaceholder("14").setValue(this.plugin.settings.calloutFontSize.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.calloutFontSize = numValue;
        await this.plugin.saveSettings();
        this.plugin.injectCustomCalloutCSS();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Breadcrumb Font Size").setDesc("Font size for breadcrumb navigation in pixels").addText((text) => text.setPlaceholder("12").setValue(this.plugin.settings.breadcrumbFontSize.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.breadcrumbFontSize = numValue;
        await this.plugin.saveSettings();
        this.plugin.injectCustomCalloutCSS();
      }
    }));
    containerEl.createEl("h3", { text: "Drag Options" });
    const dragContainer = containerEl.createEl("div", { cls: "callout-settings-indent" });
    new import_obsidian.Setting(dragContainer).setName("Use Embed Links").setDesc("Use embed links (![[...]]) instead of regular links ([[...]]) when dragging callouts").addToggle((toggle) => toggle.setValue(this.plugin.settings.useEmbedLinks).onChange(async (value) => {
      this.plugin.settings.useEmbedLinks = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(dragContainer).setName("Invisible Embeddings").setDesc("Make embedded callouts appear seamlessly without padding or borders").addToggle((toggle) => toggle.setValue(this.plugin.settings.invisibleEmbeddings).onChange(async (value) => {
      this.plugin.settings.invisibleEmbeddings = value;
      await this.plugin.saveSettings();
      this.plugin.injectCustomCalloutCSS();
    }));
    new import_obsidian.Setting(dragContainer).setName("Hide file names in links").setDesc("When dragging callouts, hide file names by adding aliases. Example: [[filename#^theorem-def456|theorem-def456]]").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideFileNamesInLinks).onChange(async (value) => {
      this.plugin.settings.hideFileNamesInLinks = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Search Options" });
    const searchContainer = containerEl.createEl("div", { cls: "callout-settings-indent" });
    new import_obsidian.Setting(searchContainer).setName("Excluded Folders").setDesc("Exclude these folders from search (comma-separated)").addTextArea((text) => text.setPlaceholder("folder1, folder2/subfolder").setValue(this.plugin.settings.excludedFolders.join(", ")).onChange(async (value) => {
      this.plugin.settings.excludedFolders = value.split(",").map((s) => s.trim()).filter((s) => s);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(searchContainer).setName("Maximum Search Results").setDesc("Limit the number of search results to improve performance").addText((text) => text.setPlaceholder("50").setValue(this.plugin.settings.maxSearchResults.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.maxSearchResults = numValue;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(searchContainer).setName("Search in Filenames").setDesc("Include file paths and names in search results").addToggle((toggle) => toggle.setValue(this.plugin.settings.searchInFilenames).onChange(async (value) => {
      this.plugin.settings.searchInFilenames = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(searchContainer).setName("Search in Callout Titles").setDesc("Include callout titles (> [!type] Callout Titles) in search results").addToggle((toggle) => toggle.setValue(this.plugin.settings.searchInCalloutTitles).onChange(async (value) => {
      this.plugin.settings.searchInCalloutTitles = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(searchContainer).setName("Search in Callout IDs").setDesc("Include callout identifiers (^callout-id) in search results").addToggle((toggle) => toggle.setValue(this.plugin.settings.searchInCalloutIds).onChange(async (value) => {
      this.plugin.settings.searchInCalloutIds = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(searchContainer).setName("Search in Callout Content").setDesc("Include callout content/body text in search results").addToggle((toggle) => toggle.setValue(this.plugin.settings.searchInCalloutContent).onChange(async (value) => {
      this.plugin.settings.searchInCalloutContent = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    containerEl.createEl("h3", { text: "Callout Options" });
    const calloutOptionsContainer = containerEl.createEl("div", { cls: "callout-settings-indent" });
    calloutOptionsContainer.createEl("p", {
      text: "\u{1F4A1} Note: Some CSS changes may require restarting Obsidian to take full effect.",
      cls: "setting-item-description"
    });
    const githubLinkContainer = calloutOptionsContainer.createEl("p", {
      cls: "setting-item-description"
    });
    githubLinkContainer.createEl("span", {
      text: "See recommended CSS snippets and colors at: "
    });
    const githubLink = githubLinkContainer.createEl("a", {
      text: "https://github.com/mathmaid/obsidian-callout-organizer",
      href: "https://github.com/mathmaid/obsidian-callout-organizer"
    });
    githubLink.addEventListener("click", (e) => {
      e.preventDefault();
      window.open("https://github.com/mathmaid/obsidian-callout-organizer", "_blank");
    });
    calloutOptionsContainer.createEl("h4", { text: "Custom CSS" });
    new import_obsidian.Setting(calloutOptionsContainer).setName("Custom Callout CSS").setDesc("Add custom CSS properties that apply to ALL callouts throughout Obsidian (editor and plugin)").addTextArea((text) => {
      text.setPlaceholder("/* custom css snippets */");
      text.setValue(this.plugin.settings.customCalloutCSS);
      text.onChange(async (value) => {
        this.plugin.settings.customCalloutCSS = value;
        await this.plugin.saveSettings();
        this.plugin.injectCustomCalloutCSS();
      });
    });
    calloutOptionsContainer.createEl("h4", { text: "Callout Colors" });
    const colorsContainer = calloutOptionsContainer.createEl("div");
    colorsContainer.createEl("p", {
      text: "Customize colors for callout types found in your vault. New callout types are automatically detected.",
      cls: "setting-item-description"
    });
    this.createDynamicCalloutColorSettings(colorsContainer);
    this.addCanvasOptions(containerEl);
  }
  async createDynamicCalloutColorSettings(container) {
    const loadingEl = container.createEl("p", { text: "Scanning vault for callout types...", cls: "setting-item-description" });
    try {
      const vaultTypes = await this.plugin.getAllCalloutTypesInVault();
      const cachedTypes = await this.plugin.getAllCalloutTypesFromCache();
      const detectedTypes = /* @__PURE__ */ new Set([...vaultTypes, ...cachedTypes]);
      const sortedTypes = Array.from(detectedTypes).sort();
      loadingEl.remove();
      if (sortedTypes.length === 0) {
        container.createEl("p", { text: "No callouts found in your vault.", cls: "setting-item-description" });
        return;
      }
      for (const type of sortedTypes) {
        if (!this.plugin.settings.calloutColors[type]) {
          if (this.plugin.isBuiltinCalloutType(type)) {
            const obsidianColor = this.plugin.getObsidianCalloutColor(type);
            this.plugin.settings.calloutColors[type] = {
              color: obsidianColor,
              icon: this.plugin.getDefaultIconForCalloutType(type)
            };
          } else {
            this.plugin.settings.calloutColors[type] = {
              color: this.getDefaultColorForType(type),
              icon: this.getDefaultIconForCalloutType(type)
            };
          }
        } else if (!this.plugin.settings.calloutColors[type].icon) {
          this.plugin.settings.calloutColors[type].icon = this.getDefaultIconForCalloutType(type);
        }
      }
      await this.plugin.saveSettings();
      this.plugin.injectCustomCalloutCSS();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
      container.createEl("p", {
        text: `Found ${sortedTypes.length} callout types in your vault.`,
        cls: "setting-item-description"
      });
      const builtinTypes = sortedTypes.filter((type) => this.plugin.isBuiltinCalloutType(type));
      const userTypes = sortedTypes.filter((type) => !this.plugin.isBuiltinCalloutType(type));
      if (builtinTypes.length > 0) {
        container.createEl("h5", { text: "Built-in Obsidian Callouts" });
        container.createEl("p", {
          text: `${builtinTypes.length} built-in callout types. Reset button restores Obsidian defaults.`,
          cls: "setting-item-description"
        });
        for (const type of builtinTypes) {
          const colors = this.plugin.settings.calloutColors[type];
          this.createCalloutSetting(container, type, colors, true);
        }
      }
      if (userTypes.length > 0) {
        container.createEl("h5", { text: "Custom Callouts" });
        container.createEl("p", {
          text: `${userTypes.length} custom callout types. Reset button sets to note callout defaults.`,
          cls: "setting-item-description"
        });
        for (const type of userTypes) {
          const colors = this.plugin.settings.calloutColors[type];
          this.createCalloutSetting(container, type, colors, false);
        }
      }
    } catch (error) {
      loadingEl.textContent = "Error scanning vault for callouts.";
      console.error("Error scanning for callouts:", error);
    }
  }
  createCalloutSetting(container, type, colors, isBuiltin) {
    const setting = new import_obsidian.Setting(container).setName(`${type.charAt(0).toUpperCase() + type.slice(1)} Callout`);
    const iconPreview = setting.controlEl.createDiv({ cls: "callout-icon-preview" });
    const updateIconPreview = () => {
      iconPreview.empty();
      if (colors.icon && colors.icon !== "none") {
        if (type === "note" && colors.icon === "pencil") {
          iconPreview.innerHTML = OBSIDIAN_NOTE_ICON_SVG;
        } else {
          (0, import_obsidian.setIcon)(iconPreview, colors.icon);
        }
        iconPreview.style.color = colors.color;
      }
    };
    updateIconPreview();
    let colorPicker;
    let dropdownRef;
    setting.addColorPicker((color) => {
      colorPicker = color;
      return color.setValue(colors.color).onChange(async (value) => {
        this.plugin.settings.calloutColors[type].color = value;
        await this.plugin.saveSettings();
        this.plugin.injectCustomCalloutCSS();
        updateIconPreview();
        const view = this.plugin.getCalloutView();
        if (view) {
          await view.refreshCallouts();
        }
      });
    }).addDropdown((dropdown) => {
      dropdownRef = dropdown;
      dropdown.addOption("none", "No Icon");
      const lucideIcons = [
        // Basic shapes and symbols
        "circle",
        "square",
        "triangle",
        "diamond",
        "hexagon",
        "star",
        "heart",
        // UI and interface
        "pencil",
        "edit",
        "edit-2",
        "edit-3",
        "pen-tool",
        "brush",
        "palette",
        "info",
        "alert-circle",
        "alert-triangle",
        "alert-octagon",
        "help-circle",
        "question-mark",
        "exclamation",
        "check",
        "check-circle",
        "check-circle-2",
        "x",
        "x-circle",
        "minus",
        "minus-circle",
        "plus",
        "plus-circle",
        // Files and documents
        "file",
        "file-text",
        "book",
        "book-open",
        "notebook",
        "scroll",
        "document",
        "page",
        "pages",
        "bookmark",
        "tag",
        "tags",
        "clipboard-list",
        // Communication and social
        "message-circle",
        "message-square",
        "quote",
        "speech",
        "comment",
        "chat",
        "mail",
        "phone",
        "bell",
        "megaphone",
        // Technology and tools
        "zap",
        "flash",
        "bolt",
        "cpu",
        "hard-drive",
        "database",
        "server",
        "code",
        "terminal",
        "command",
        "bug",
        "wrench",
        "tool",
        "settings",
        // Science and education
        "atom",
        "beaker",
        "flask",
        "microscope",
        "telescope",
        "graduation-cap",
        "calculator",
        "ruler",
        "compass",
        "protractor",
        "formula",
        // Nature and objects
        "sun",
        "moon",
        "star-filled",
        "cloud",
        "umbrella",
        "tree",
        "flower",
        "leaf",
        "flame",
        "droplet",
        "snowflake",
        // Navigation and movement
        "arrow-up",
        "arrow-down",
        "arrow-left",
        "arrow-right",
        "navigation",
        "compass-2",
        "map",
        "map-pin",
        "target",
        "crosshair",
        // Time and calendar
        "clock",
        "watch",
        "timer",
        "calendar",
        "calendar-days",
        "hourglass",
        // Media and entertainment
        "image",
        "camera",
        "video",
        "music",
        "headphones",
        "mic",
        "play",
        "pause",
        "stop",
        "film",
        "tv",
        // Business and finance
        "briefcase",
        "building",
        "bank",
        "credit-card",
        "dollar-sign",
        "trending-up",
        "trending-down",
        "bar-chart",
        "pie-chart",
        // Health and medical
        "activity",
        "heart-pulse",
        "pill",
        "syringe",
        "thermometer",
        "first-aid",
        "cross",
        "shield",
        "shield-check",
        // Transportation
        "car",
        "truck",
        "bike",
        "plane",
        "ship",
        "train",
        "bus",
        // Food and dining
        "coffee",
        "cup",
        "utensils",
        "pizza",
        "apple",
        "cherry",
        // Sports and games
        "gamepad",
        "dice",
        "trophy",
        "medal",
        "flag",
        "target-2",
        // Miscellaneous
        "lightbulb",
        "key",
        "lock",
        "unlock",
        "eye",
        "eye-off",
        "glasses",
        "gem",
        "gift",
        "magic-wand",
        "puzzle",
        "layers",
        "layout",
        "grid",
        "list",
        "menu",
        "more-horizontal"
      ];
      lucideIcons.forEach((icon) => {
        dropdown.addOption(icon, icon.charAt(0).toUpperCase() + icon.slice(1).replace(/-/g, " "));
      });
      dropdown.setValue(colors.icon || "none");
      dropdown.onChange(async (value) => {
        this.plugin.settings.calloutColors[type].icon = value;
        await this.plugin.saveSettings();
        this.plugin.injectCustomCalloutCSS();
        updateIconPreview();
        const view = this.plugin.getCalloutView();
        if (view) {
          await view.refreshCallouts();
        }
      });
      return dropdown;
    }).addButton((button) => {
      const tooltipText = isBuiltin ? "Reset to Obsidian default color and icon" : "Reset to note callout defaults";
      button.setTooltip(tooltipText);
      (0, import_obsidian.setIcon)(button.buttonEl, "rotate-ccw");
      button.onClick(async () => {
        let defaultColor;
        let defaultIcon;
        if (isBuiltin) {
          defaultColor = this.plugin.getDefaultColorForCalloutType(type);
          defaultIcon = this.plugin.getDefaultIconForCalloutType(type);
        } else {
          defaultColor = this.plugin.getDefaultColorForCalloutType("note");
          defaultIcon = this.plugin.getDefaultIconForCalloutType("note");
        }
        this.plugin.settings.calloutColors[type].color = defaultColor;
        this.plugin.settings.calloutColors[type].icon = defaultIcon;
        await this.plugin.saveSettings();
        this.plugin.injectCustomCalloutCSS();
        if (dropdownRef)
          dropdownRef.setValue(defaultIcon);
        if (colorPicker)
          colorPicker.setValue(defaultColor);
        updateIconPreview();
        const view = this.plugin.getCalloutView();
        if (view) {
          await view.refreshCallouts();
        }
      });
    });
  }
  getDefaultColorForType(type) {
    return this.plugin.getDefaultColorForCalloutType(type);
  }
  getDefaultIconForCalloutType(type) {
    return this.plugin.getDefaultIconForCalloutType(type);
  }
  addCanvasOptions(containerEl) {
    containerEl.createEl("h3", { text: "Canvas Settings" });
    const canvasContainer = containerEl.createEl("div", { cls: "callout-settings-indent" });
    new import_obsidian.Setting(canvasContainer).setName("Canvas Storage Folder").setDesc("Folder where callout canvas files will be stored (relative to vault root)").addText((text) => text.setPlaceholder("Callout Connections").setValue(this.plugin.settings.canvasStorageFolder).onChange(async (value) => {
      this.plugin.settings.canvasStorageFolder = value || "Callout Connections";
      await this.plugin.saveSettings();
    }));
  }
};
