/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => CalloutOrganizerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var OBSIDIAN_NOTE_ICON_SVG = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-pencil"><path d="M21.174 6.812a1 1 0 0 0-3.986-3.987L3.842 16.174a2 2 0 0 0-.5.83l-1.321 4.352a.5.5 0 0 0 .623.622l4.353-1.32a2 2 0 0 0 .83-.497z"></path><path d="m15 5 4 4"></path></svg>`;
var DEFAULT_SETTINGS = {
  excludedFolders: [],
  groupByType: false,
  // Show in file order by default
  searchInFilenames: true,
  searchInCalloutTitles: true,
  searchInCalloutIds: true,
  searchInCalloutContent: true,
  maxSearchResults: 50,
  // Cache settings
  enableFileCache: true,
  // Display options - show all by default
  showFilenames: true,
  showH1Headers: true,
  showH2Headers: true,
  showH3Headers: true,
  showH4Headers: true,
  showH5Headers: true,
  showH6Headers: true,
  showCalloutIds: true,
  calloutFontSize: 14,
  breadcrumbFontSize: 12,
  // Drag options
  useEmbedLinks: true,
  // Use embed links by default
  invisibleEmbeddings: true,
  // Enable invisible embeddings by default
  hideFileNamesInLinks: false,
  // Hide file names in links by default (disabled)
  // Callout options
  customCalloutCSS: "",
  // Callout colors will be dynamically populated based on detected callouts in vault
  calloutColors: {}
};
var VIEW_TYPE_CALLOUT_ORGANIZER = "callout-organizer";
function timestampToReadable(timestamp) {
  const date = new Date(timestamp);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const day = String(date.getDate()).padStart(2, "0");
  const hours = String(date.getHours()).padStart(2, "0");
  const minutes = String(date.getMinutes()).padStart(2, "0");
  const seconds = String(date.getSeconds()).padStart(2, "0");
  return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}
function readableToTimestamp(readable) {
  return new Date(readable).getTime();
}
function hasCalloutChanged(newCallout, existingCallout) {
  return newCallout.type !== existingCallout.type || newCallout.title !== existingCallout.title || newCallout.content !== existingCallout.content;
}
var CalloutOrganizerView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin, mode = "current") {
    super(leaf);
    this.callouts = [];
    this.activeFilters = /* @__PURE__ */ new Set();
    this.searchQuery = "";
    // Debouncing and performance optimizations
    this.refreshDebounceTimer = null;
    this.searchDebounceTimer = null;
    this.lastRenderTime = 0;
    this.DEBOUNCE_DELAY = 300;
    this.RENDER_BATCH_SIZE = 20;
    // Batch DOM operations
    this.MIN_RENDER_INTERVAL = 100;
    // Performance optimization: cache DOM elements
    this.topBarElement = null;
    this.calloutContainerElement = null;
    this.SEARCH_DEBOUNCE_DELAY = 200;
    this.RENDER_DEBOUNCE_DELAY = 150;
    this.plugin = plugin;
    this.component = new import_obsidian.Component();
    this.searchMode = mode;
  }
  getViewType() {
    return VIEW_TYPE_CALLOUT_ORGANIZER;
  }
  getDisplayText() {
    return this.searchMode === "search" ? "Callout Search" : "Callout View";
  }
  getIcon() {
    return "album";
  }
  async onOpen() {
    this.component.load();
    const container = this.containerEl.children[1];
    container.empty();
    const topBar = container.createEl("div", { cls: "callout-top-bar" });
    this.setupTopBar(topBar);
    const calloutContainer = container.createEl("div", { cls: "callout-container" });
    this.renderCallouts(calloutContainer);
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => {
      if (this.searchMode === "current") {
        this.refreshCallouts();
      }
    }));
    this.registerEvent(this.app.vault.on("modify", () => {
      if (this.searchMode === "search") {
        console.log("File modified, cache will be validated on next access");
      }
    }));
    await this.refreshCallouts();
  }
  async refreshCallouts() {
    if (this.searchMode === "current") {
      this.callouts = await this.plugin.extractCurrentFileCallouts();
    } else if (this.searchMode === "search") {
      console.log("Refreshing search mode callouts...");
      this.callouts = await this.plugin.extractAllCallouts();
      console.log(`Loaded ${this.callouts.length} callouts for search mode`);
    }
    const container = this.containerEl.querySelector(".callout-container");
    if (container) {
      await this.renderCallouts(container);
    }
  }
  async getHeadingHierarchy(callout) {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      return [];
    }
    const content = await this.app.vault.read(activeFile);
    const lines = content.split("\n");
    const headings = [];
    for (let i = 0; i < callout.lineNumber - 1; i++) {
      const line = lines[i].trim();
      const headingMatch = line.match(/^(#{1,6})\s+(.+)$/);
      if (headingMatch) {
        const level = headingMatch[1].length;
        const title = headingMatch[2].trim();
        headings.push({
          title,
          level,
          lineNumber: i + 1
        });
      }
    }
    const hierarchy = [];
    for (const heading of headings) {
      while (hierarchy.length > 0 && hierarchy[hierarchy.length - 1].level >= heading.level) {
        hierarchy.pop();
      }
      hierarchy.push(heading);
    }
    return hierarchy;
  }
  filterHeadersBySettings(headers, headerLevels) {
    if (!headerLevels || headers.length !== headerLevels.length) {
      return headers;
    }
    const filtered = [];
    for (let i = 0; i < headers.length; i++) {
      const level = headerLevels[i];
      let shouldInclude = false;
      switch (level) {
        case 1:
          shouldInclude = this.plugin.settings.showH1Headers;
          break;
        case 2:
          shouldInclude = this.plugin.settings.showH2Headers;
          break;
        case 3:
          shouldInclude = this.plugin.settings.showH3Headers;
          break;
        case 4:
          shouldInclude = this.plugin.settings.showH4Headers;
          break;
        case 5:
          shouldInclude = this.plugin.settings.showH5Headers;
          break;
        case 6:
          shouldInclude = this.plugin.settings.showH6Headers;
          break;
        default:
          shouldInclude = true;
      }
      if (shouldInclude) {
        filtered.push(headers[i]);
      }
    }
    return filtered;
  }
  getSearchPlaceholder() {
    if (this.searchMode === "current") {
      return "Search current file...";
    }
    const enabledFields = [];
    if (this.plugin.settings.searchInFilenames)
      enabledFields.push("files");
    if (this.plugin.settings.searchInCalloutTitles)
      enabledFields.push("callout titles");
    if (this.plugin.settings.searchInCalloutIds)
      enabledFields.push("callout IDs");
    if (this.plugin.settings.searchInCalloutContent)
      enabledFields.push("callout content");
    if (enabledFields.length === 0) {
      return "Search disabled - enable search fields in settings";
    }
    return "Search all files...";
  }
  setupTopBar(container) {
    container.empty();
    const firstLine = container.createEl("div", { cls: "callout-top-bar-line-1" });
    const modeToggleBtn = firstLine.createEl("button", {
      text: this.searchMode === "current" ? "Current File" : "All Files",
      cls: "callout-mode-toggle-button"
    });
    modeToggleBtn.onmousedown = async (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (this.searchMode === "current") {
        this.searchMode = "search";
        modeToggleBtn.textContent = "All Files";
      } else {
        this.searchMode = "current";
        modeToggleBtn.textContent = "Current File";
        this.searchQuery = "";
      }
      this.activeFilters.clear();
      await this.refreshCallouts();
      const uniqueTypes = new Set(this.callouts.map((callout) => callout.type));
      uniqueTypes.forEach((type) => this.activeFilters.add(type));
      await this.refreshCallouts();
    };
    const searchInput = firstLine.createEl("input", {
      type: "text",
      placeholder: this.getSearchPlaceholder(),
      cls: "callout-search-input",
      value: this.searchQuery
    });
    searchInput.oninput = () => {
      this.searchQuery = searchInput.value;
      this.debouncedSearch();
    };
    const rightButtons = firstLine.createEl("div", { cls: "callout-right-buttons" });
    const refreshBtn = rightButtons.createEl("button", {
      cls: "callout-refresh-button"
    });
    (0, import_obsidian.setIcon)(refreshBtn, "refresh-cw");
    refreshBtn.onclick = async () => {
      if (this.searchMode === "search") {
        new import_obsidian.Notice("Rescanning all files and updating cache...");
        this.callouts = await this.plugin.refreshAllCallouts();
        const container2 = this.containerEl.querySelector(".callout-container");
        if (container2) {
          await this.renderCallouts(container2);
        }
        new import_obsidian.Notice(`Search results refreshed! Found ${this.callouts.length} callouts. Cache updated.`);
      } else {
        new import_obsidian.Notice("Refreshing current file and updating cache...");
        await this.plugin.refreshAllCallouts();
        await this.refreshCallouts();
        new import_obsidian.Notice("Current file callouts refreshed! Cache updated.");
      }
    };
    const secondLine = container.createEl("div", { cls: "callout-top-bar-line-2" });
    const typeSelectors = secondLine.createEl("div", { cls: "callout-type-selectors" });
    this.setupTypeSelectors(typeSelectors);
  }
  setupTypeSelectors(container) {
    container.empty();
    const uniqueTypes = [...new Set(this.callouts.map((c) => c.type))].sort();
    if (uniqueTypes.length === 0) {
      container.createEl("p", { text: "No callout types found", cls: "callout-empty-message" });
      return;
    }
    if (this.activeFilters.size === 0) {
      uniqueTypes.forEach((type) => this.activeFilters.add(type));
    }
    if (uniqueTypes.length > 0) {
      const allSelected = this.activeFilters.size === uniqueTypes.length;
      const toggleButton = container.createEl("button", {
        text: allSelected ? "Clear All" : "Select All",
        cls: "callout-clear-all-button"
      });
      toggleButton.onclick = (e) => {
        e.stopPropagation();
        const currentlyAllSelected = this.activeFilters.size === uniqueTypes.length;
        if (currentlyAllSelected) {
          this.activeFilters.clear();
          const allButtons = container.querySelectorAll(".callout-type-selector");
          allButtons.forEach((btn) => btn.removeClass("active"));
          toggleButton.textContent = "Select All";
        } else {
          this.activeFilters.clear();
          uniqueTypes.forEach((type) => this.activeFilters.add(type));
          const allButtons = container.querySelectorAll(".callout-type-selector");
          allButtons.forEach((btn) => btn.addClass("active"));
          toggleButton.textContent = "Clear All";
        }
        this.debouncedRender();
      };
    }
    uniqueTypes.forEach((type) => {
      var _a;
      const button = container.createEl("button", {
        cls: `callout-type-selector callout-filter-${type}`
      });
      const iconName = (_a = this.plugin.settings.calloutColors[type]) == null ? void 0 : _a.icon;
      if (iconName && iconName !== "none") {
        const iconEl = button.createEl("span", { cls: "callout-type-icon" });
        if (type === "note" && iconName === "pencil") {
          iconEl.innerHTML = OBSIDIAN_NOTE_ICON_SVG;
        } else {
          (0, import_obsidian.setIcon)(iconEl, iconName);
        }
        iconEl.style.marginRight = "4px";
        iconEl.style.width = "calc(var(--callout-font-size, 14px) * 16 / 14)";
        iconEl.style.height = "calc(var(--callout-font-size, 14px) * 16 / 14)";
        iconEl.style.display = "inline-flex";
        iconEl.style.alignItems = "center";
      }
      button.createEl("span", {
        text: type.charAt(0).toUpperCase() + type.slice(1),
        cls: "callout-type-text"
      });
      if (this.activeFilters.has(type)) {
        button.addClass("active");
      }
      button.onclick = (e) => {
        e.stopPropagation();
        if (this.activeFilters.has(type)) {
          this.activeFilters.delete(type);
        } else {
          this.activeFilters.add(type);
        }
        if (this.activeFilters.has(type)) {
          button.addClass("active");
        } else {
          button.removeClass("active");
        }
        const toggleButton = container.querySelector(".callout-clear-all-button");
        if (toggleButton) {
          const allSelected = this.activeFilters.size === uniqueTypes.length;
          toggleButton.textContent = allSelected ? "Clear All" : "Select All";
        }
        this.debouncedRender();
      };
    });
  }
  getFilteredCallouts() {
    if (this.activeFilters.size === 0) {
      return [];
    }
    let filtered = this.callouts.filter((callout) => this.activeFilters.has(callout.type));
    if (this.searchQuery.trim()) {
      const query = this.searchQuery.toLowerCase();
      const keywords = query.split(/\s+/).filter((k) => k.length > 0);
      const settings = this.plugin.settings;
      filtered = filtered.filter((callout) => {
        let searchText = "";
        if (this.searchMode === "search") {
          if (settings.searchInFilenames) {
            searchText += callout.file.toLowerCase() + " ";
          }
          if (settings.searchInCalloutTitles) {
            searchText += callout.title.toLowerCase() + " ";
          }
          if (settings.searchInCalloutIds && callout.calloutID) {
            searchText += callout.calloutID.toLowerCase() + " ";
          }
          if (settings.searchInCalloutContent) {
            searchText += callout.content.toLowerCase() + " ";
          }
        } else {
          searchText += callout.file.toLowerCase() + " ";
          if (callout.headers) {
            searchText += callout.headers.join(" ").toLowerCase() + " ";
          }
          searchText += callout.title.toLowerCase() + " ";
          if (callout.calloutID) {
            searchText += callout.calloutID.toLowerCase() + " ";
          }
          searchText += callout.content.toLowerCase() + " ";
        }
        return keywords.every((keyword) => searchText.includes(keyword));
      });
    }
    if (this.searchMode === "search" && filtered.length > this.plugin.settings.maxSearchResults) {
      filtered = filtered.slice(0, this.plugin.settings.maxSearchResults);
    }
    return filtered;
  }
  async renderCalloutsList(container) {
    container.empty();
    const filteredCallouts = this.getFilteredCallouts();
    if (filteredCallouts.length === 0) {
      let message = "No callouts found.";
      if (this.activeFilters.size === 0) {
        message = "No callout types selected.";
      } else if (this.searchQuery.trim()) {
        message = `No callouts found matching "${this.searchQuery}".`;
      } else {
        message = "No callouts found for selected types.";
      }
      container.createEl("p", { text: message, cls: "callout-empty-message" });
      return;
    }
    let calloutsToRender;
    if (this.plugin.settings.groupByType) {
      const grouped = this.groupFilteredCallouts(filteredCallouts);
      for (const [type, callouts] of Object.entries(grouped)) {
        container.createEl("h3", {
          text: type.charAt(0).toUpperCase() + type.slice(1) + "s",
          cls: `callout-organizer-type-header callout-organizer-type-header-${type}`
        });
        for (const callout of callouts) {
          await this.renderSingleCallout(container, callout);
        }
      }
    } else {
      calloutsToRender = [...filteredCallouts].sort((a, b) => {
        if (this.searchMode === "search") {
          const aModTime = a.calloutModifyTime || a.fileModTime || "1970-01-01 00:00:00";
          const bModTime = b.calloutModifyTime || b.fileModTime || "1970-01-01 00:00:00";
          return readableToTimestamp(bModTime) - readableToTimestamp(aModTime);
        } else {
          return a.lineNumber - b.lineNumber;
        }
      });
      for (const callout of calloutsToRender) {
        await this.renderSingleCallout(container, callout);
      }
    }
  }
  async renderCallouts(container) {
    const topBar = this.containerEl.querySelector(".callout-top-bar");
    if (topBar) {
      this.setupTopBar(topBar);
    }
    await this.renderCalloutsList(container);
  }
  async renderSingleCallout(container, callout) {
    var _a, _b, _c, _d;
    const calloutEl = container.createEl("div", { cls: "callout-organizer-item" });
    calloutEl.addClass("callout");
    calloutEl.setAttr("data-callout", callout.type);
    if (this.searchMode === "search") {
      calloutEl.addClass("callout-organizer-search-mode");
    }
    calloutEl.style.cursor = "pointer";
    calloutEl.draggable = true;
    calloutEl.onclick = (e) => {
      if (e.target.tagName === "A") {
        return;
      }
      e.preventDefault();
      this.openFile(callout.file, callout.lineNumber, e.ctrlKey || e.metaKey);
    };
    calloutEl.ondragstart = (e) => {
      if (e.dataTransfer) {
        let calloutID = callout.calloutID;
        let needsNewId = false;
        if (!calloutID) {
          calloutID = this.generateCalloutId(callout);
          callout.calloutID = calloutID;
          needsNewId = true;
        }
        const useEmbed = this.plugin.settings.useEmbedLinks;
        const filenameWithExt = callout.file.split("/").pop() || callout.file;
        const filename = filenameWithExt.replace(/\.md$/, "");
        let linkText;
        if (this.plugin.settings.hideFileNamesInLinks) {
          const alias = this.generateCalloutAlias(callout, calloutID);
          linkText = useEmbed ? `![[${filename}#^${calloutID}|${alias}]]` : `[[${filename}#^${calloutID}|${alias}]]`;
        } else {
          linkText = useEmbed ? `![[${filename}#^${calloutID}]]` : `[[${filename}#^${calloutID}]]`;
        }
        e.dataTransfer.setData("text/plain", linkText);
        e.dataTransfer.effectAllowed = "copy";
        calloutEl.style.opacity = "0.5";
        if (needsNewId && calloutID) {
          queueMicrotask(() => {
            this.addCalloutIdToCallout(callout, calloutID).catch((error) => {
              console.error("Error adding callout ID to file:", error);
            });
          });
        }
      }
    };
    calloutEl.ondragend = () => {
      calloutEl.style.opacity = "1";
    };
    const header = calloutEl.createEl("div", { cls: "callout-organizer-header" });
    const displayTitle = callout.title || callout.type.charAt(0).toUpperCase() + callout.type.slice(1);
    if (displayTitle) {
      const titleEl = header.createEl("span", {
        cls: "callout-organizer-title"
      });
      const calloutColor = ((_a = this.plugin.settings.calloutColors[callout.type]) == null ? void 0 : _a.color) || "var(--callout-title-color)";
      const iconName = (_b = this.plugin.settings.calloutColors[callout.type]) == null ? void 0 : _b.icon;
      if (iconName && iconName !== "none") {
        const iconEl = titleEl.createEl("span", { cls: "callout-title-icon" });
        if (callout.type === "note" && iconName === "pencil") {
          iconEl.innerHTML = OBSIDIAN_NOTE_ICON_SVG;
        } else {
          (0, import_obsidian.setIcon)(iconEl, iconName);
        }
        iconEl.style.marginRight = "6px";
        iconEl.style.width = "calc(var(--callout-font-size, 14px) * 16 / 14)";
        iconEl.style.height = "calc(var(--callout-font-size, 14px) * 16 / 14)";
        iconEl.style.display = "inline-flex";
        iconEl.style.alignItems = "center";
        iconEl.style.color = calloutColor;
      }
      titleEl.style.color = calloutColor;
      import_obsidian.MarkdownRenderer.render(this.app, displayTitle, titleEl, callout.file, this.component).then(() => {
        this.processMathForElement(titleEl);
        titleEl.style.color = calloutColor;
      });
    }
    const content = calloutEl.createEl("div", { cls: "callout-organizer-content" });
    import_obsidian.MarkdownRenderer.render(this.app, callout.content, content, callout.file, this.component).then(() => {
      this.processMathForElement(content);
    });
    const breadcrumb = calloutEl.createEl("div", { cls: "callout-organizer-breadcrumb" });
    if (this.plugin.settings.showFilenames) {
      const fileParts = (_c = callout.file) == null ? void 0 : _c.split("/");
      const filename = ((_d = fileParts == null ? void 0 : fileParts.pop()) == null ? void 0 : _d.replace(/\.md$/, "")) || callout.file || "Unknown";
      const fileLink = breadcrumb.createEl("a", {
        text: filename,
        href: "#",
        cls: "callout-organizer-file-link"
      });
      fileLink.onclick = (e) => {
        e.preventDefault();
        this.openFile(callout.file, callout.lineNumber, e.ctrlKey || e.metaKey);
      };
    }
    if (callout.headers && callout.headers.length > 0) {
      const filteredHeaders = this.filterHeadersBySettings(callout.headers, callout.headerLevels);
      for (const headerTitle of filteredHeaders) {
        if (breadcrumb.children.length > 0) {
          breadcrumb.createEl("span", {
            text: " > ",
            cls: "callout-organizer-breadcrumb-separator"
          });
        }
        const headingLink = breadcrumb.createEl("a", {
          text: headerTitle,
          href: "#",
          cls: "callout-organizer-heading-link"
        });
        headingLink.onclick = (e) => {
          e.preventDefault();
          this.openFile(callout.file, callout.lineNumber, e.ctrlKey || e.metaKey);
        };
      }
    }
    if (callout.calloutID && this.plugin.settings.showCalloutIds) {
      if (breadcrumb.children.length > 0) {
        breadcrumb.createEl("span", {
          text: " > ",
          cls: "callout-organizer-breadcrumb-separator"
        });
      }
      const blockLink = breadcrumb.createEl("a", {
        text: `^${callout.calloutID}`,
        href: "#",
        cls: "callout-organizer-callout-id"
      });
      blockLink.onclick = (e) => {
        e.preventDefault();
        this.openFile(callout.file, callout.lineNumber, e.ctrlKey || e.metaKey);
      };
    }
  }
  groupCallouts() {
    return this.groupFilteredCallouts(this.callouts);
  }
  groupFilteredCallouts(callouts) {
    const grouped = {};
    callouts.forEach((callout) => {
      if (!grouped[callout.type]) {
        grouped[callout.type] = [];
      }
      grouped[callout.type].push(callout);
    });
    Object.keys(grouped).forEach((type) => {
      grouped[type].sort((a, b) => {
        if (this.searchMode === "search") {
          const aModTime = a.calloutModifyTime || a.fileModTime || "1970-01-01 00:00:00";
          const bModTime = b.calloutModifyTime || b.fileModTime || "1970-01-01 00:00:00";
          return readableToTimestamp(bModTime) - readableToTimestamp(aModTime);
        } else {
          return a.lineNumber - b.lineNumber;
        }
      });
    });
    return grouped;
  }
  generateCalloutAlias(_callout, calloutID) {
    return calloutID;
  }
  generateCalloutId(callout) {
    const type = callout.type.toLowerCase();
    const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
    let randomChars = "";
    for (let i = 0; i < 6; i++) {
      randomChars += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return `${type}-${randomChars}`;
  }
  async addCalloutIdToCallout(callout, calloutID) {
    try {
      const file = this.app.vault.getAbstractFileByPath(callout.file);
      if (!(file instanceof import_obsidian.TFile)) {
        new import_obsidian.Notice(`File not found: ${callout.file}`);
        return;
      }
      const content = await this.app.vault.read(file);
      if (!content && content !== "") {
        new import_obsidian.Notice(`Failed to read file: ${callout.file}`);
        return;
      }
      const lines = content.split("\n");
      let lastCalloutLineIndex = -1;
      let actualStartLine = -1;
      const expectedLine = callout.lineNumber - 1;
      const searchRange = 10;
      const linesToSearch = [expectedLine];
      for (let i = 1; i <= searchRange; i++) {
        if (expectedLine - i >= 0) {
          linesToSearch.push(expectedLine - i);
        }
      }
      for (let i = 1; i <= searchRange; i++) {
        if (expectedLine + i < lines.length) {
          linesToSearch.push(expectedLine + i);
        }
      }
      for (const lineIndex of linesToSearch) {
        const line = lines[lineIndex];
        const calloutMatch = line.trim().match(/^>\s*\[!([^\]]+)\]\s*(.*)/);
        if (calloutMatch) {
          const foundType = calloutMatch[1];
          const foundTitle = calloutMatch[2].trim();
          if (foundType.toLowerCase() === callout.type.toLowerCase()) {
            if (callout.title && foundTitle) {
              const normalizedCalloutTitle = callout.title.trim().toLowerCase();
              const normalizedFoundTitle = foundTitle.trim().toLowerCase();
              if (normalizedCalloutTitle === normalizedFoundTitle || normalizedCalloutTitle.includes(normalizedFoundTitle) || normalizedFoundTitle.includes(normalizedCalloutTitle)) {
                actualStartLine = lineIndex;
                lastCalloutLineIndex = lineIndex;
                break;
              }
            } else {
              actualStartLine = lineIndex;
              lastCalloutLineIndex = lineIndex;
              break;
            }
          }
        }
      }
      if (actualStartLine >= 0) {
        for (let i = actualStartLine + 1; i < lines.length; i++) {
          const line = lines[i];
          if (line.startsWith(">")) {
            const newCalloutMatch = line.trim().match(/^>\s*\[!([^\]]+)\]/);
            if (newCalloutMatch) {
              break;
            } else {
              lastCalloutLineIndex = i;
            }
          } else {
            break;
          }
        }
      }
      if (lastCalloutLineIndex >= 0) {
        let hasBlockId = false;
        for (let i = actualStartLine; i <= lastCalloutLineIndex; i++) {
          if (lines[i] && lines[i].match(/>\s*\^[\w-]+/)) {
            hasBlockId = true;
            break;
          }
        }
        if (!hasBlockId) {
          lines.splice(lastCalloutLineIndex + 1, 0, `> ^${calloutID}`);
          if (lastCalloutLineIndex + 2 < lines.length && lines[lastCalloutLineIndex + 2].trim() !== "") {
            lines.splice(lastCalloutLineIndex + 2, 0, "");
          } else if (lastCalloutLineIndex + 2 >= lines.length) {
            lines.push("");
          }
          await this.app.vault.modify(file, lines.join("\n"));
          callout.calloutID = calloutID;
        }
      }
    } catch (error) {
      console.error("Error adding callout ID to callout:", error);
      new import_obsidian.Notice("Failed to add callout ID to callout");
    }
  }
  async openFile(filename, lineNumber, newTab) {
    const file = this.app.vault.getAbstractFileByPath(filename);
    if (file instanceof import_obsidian.TFile) {
      let leaf;
      if (newTab) {
        leaf = this.app.workspace.getLeaf("tab");
      } else {
        leaf = this.app.workspace.getLeaf(false);
      }
      await leaf.openFile(file);
      if (lineNumber) {
        const view = leaf.view;
        if (view && "editor" in view) {
          const editor = view.editor;
          if (editor) {
            editor.setCursor(lineNumber - 1, 0);
            editor.scrollIntoView({ from: { line: lineNumber - 1, ch: 0 }, to: { line: lineNumber - 1, ch: 0 } }, true);
            setTimeout(() => {
              this.highlightLine(editor, lineNumber - 1);
            }, 100);
          }
        }
      }
    }
  }
  highlightLine(editor, lineNumber) {
    try {
      if (!editor || typeof editor !== "object" || !("lineInfo" in editor)) {
        return;
      }
      const lineInfo = editor.lineInfo(lineNumber);
      if (!lineInfo)
        return;
      const markEl = document.createElement("div");
      markEl.className = "callout-organizer-highlight";
      markEl.style.cssText = `
                position: absolute;
                left: 0;
                right: 0;
                background-color: var(--text-selection);
                opacity: 0.7;
                pointer-events: none;
                animation: callout-highlight-pulse 3s ease-out;
                z-index: 1;
            `;
      if (!document.getElementById("callout-organizer-highlight-style")) {
        const style = document.createElement("style");
        style.id = "callout-organizer-highlight-style";
        style.textContent = `
                @keyframes callout-highlight-pulse {
                    0% { opacity: 0.8; transform: scale(1.02); }
                    50% { opacity: 0.5; }
                    100% { opacity: 0; transform: scale(1); }
                }
                .callout-organizer-highlight {
                    border-radius: 3px;
                }
                `;
        document.head.appendChild(style);
      }
      const editorWithDisplay = editor;
      if (editorWithDisplay.display && editorWithDisplay.display.lineDiv && editorWithDisplay.display.lineDiv.children) {
        const lineEl = editorWithDisplay.display.lineDiv.children[lineNumber];
        if (lineEl && markEl) {
          lineEl.style.position = "relative";
          lineEl.appendChild(markEl);
          setTimeout(() => {
            if (markEl && markEl.parentNode) {
              markEl.parentNode.removeChild(markEl);
            }
          }, 3e3);
        }
      }
    } catch (error) {
      console.warn("Failed to highlight line:", error);
    }
  }
  // Performance optimization methods
  debouncedSearch() {
    if (this.searchDebounceTimer) {
      clearTimeout(this.searchDebounceTimer);
    }
    const delay = this.callouts.length > 100 ? this.SEARCH_DEBOUNCE_DELAY * 2 : this.SEARCH_DEBOUNCE_DELAY;
    this.searchDebounceTimer = setTimeout(() => {
      const calloutContainer = this.calloutContainerElement || this.containerEl.querySelector(".callout-container");
      if (calloutContainer) {
        this.renderCalloutsList(calloutContainer);
      }
    }, delay);
  }
  debouncedRender() {
    const now = Date.now();
    if (now - this.lastRenderTime < this.MIN_RENDER_INTERVAL) {
      return;
    }
    this.lastRenderTime = now;
    const calloutContainer = this.containerEl.querySelector(".callout-container");
    if (calloutContainer) {
      this.renderCalloutsList(calloutContainer);
    }
  }
  processMathForElement(element) {
    try {
      const mathJax = window.MathJax;
      if (mathJax == null ? void 0 : mathJax.typesetPromise) {
        const mathElements = element.querySelectorAll(".math, mjx-container, [data-math], .cm-math");
        if (mathElements.length > 0) {
          mathJax.typesetPromise([element]).then(() => {
            element.querySelectorAll("mjx-container").forEach((mjx) => {
              const mjxElement = mjx;
              if (mjxElement.getAttribute("display") === "true") {
                mjxElement.style.display = "block";
                mjxElement.style.textAlign = "center";
                mjxElement.style.margin = "1em 0";
              } else {
                mjxElement.style.display = "inline";
                mjxElement.style.margin = "0";
              }
            });
          }).catch(() => {
          });
        }
      }
    } catch (error) {
      console.warn("Math processing error:", error);
    }
  }
  async onClose() {
    var _a;
    if (this.refreshDebounceTimer) {
      clearTimeout(this.refreshDebounceTimer);
      this.refreshDebounceTimer = null;
    }
    if (this.searchDebounceTimer) {
      clearTimeout(this.searchDebounceTimer);
      this.searchDebounceTimer = null;
    }
    if (this.topBarElement) {
      this.topBarElement = null;
    }
    if (this.calloutContainerElement) {
      this.calloutContainerElement = null;
    }
    this.callouts = [];
    this.activeFilters.clear();
    (_a = this.component) == null ? void 0 : _a.unload();
  }
};
var _CalloutOrganizerPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.styleElement = null;
  }
  async onload() {
    await this.loadSettings();
    this.registerView(
      VIEW_TYPE_CALLOUT_ORGANIZER,
      (leaf) => new CalloutOrganizerView(leaf, this, "current")
    );
    this.addRibbonIcon("album", "Open Callout Organizer", () => {
      this.activateCalloutOrganizer();
    });
    this.addCommand({
      id: "open-callout-organizer",
      name: "Open Callout Organizer",
      callback: () => {
        this.activateCalloutOrganizer();
      }
    });
    this.addCommand({
      id: "test-cache-loading",
      name: "Test Cache Loading",
      callback: async () => {
        console.log("=== Testing Cache Loading ===");
        const cache = await this.loadCalloutCache();
        if (cache) {
          new import_obsidian.Notice(`Cache loaded successfully! Found ${cache.callouts.length} callouts.`);
          console.log("Cache data:", cache);
        } else {
          new import_obsidian.Notice("Failed to load cache or cache not found.");
          console.log("Cache loading failed");
        }
      }
    });
    this.addSettingTab(new CalloutOrganizerSettingTab(this.app, this));
    await this.initializeCalloutColors();
    this.injectCustomCalloutCSS();
  }
  async initializeCalloutColors() {
    try {
      const detectedTypes = await this.getAllCalloutTypesInVault();
      let settingsChanged = false;
      for (const type of detectedTypes) {
        if (!this.settings.calloutColors[type]) {
          if (this.isBuiltinCalloutType(type)) {
            const obsidianColor = this.getObsidianCalloutColor(type);
            this.settings.calloutColors[type] = {
              color: obsidianColor,
              icon: this.getDefaultIconForCalloutType(type)
            };
          } else {
            this.settings.calloutColors[type] = {
              color: this.getDefaultColorForCalloutType(type),
              icon: this.getDefaultIconForCalloutType(type)
            };
          }
          settingsChanged = true;
        } else if (!this.settings.calloutColors[type].icon) {
          this.settings.calloutColors[type].icon = this.getDefaultIconForCalloutType(type);
          settingsChanged = true;
        }
      }
      if (settingsChanged) {
        await this.saveSettings();
        this.injectCustomCalloutCSS();
      }
    } catch (error) {
      console.error("Error initializing callout colors:", error);
    }
  }
  hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (result) {
      return `${parseInt(result[1], 16)},${parseInt(result[2], 16)},${parseInt(result[3], 16)}`;
    }
    return "0,0,0";
  }
  async getAllCalloutTypesInVault() {
    const calloutTypes = /* @__PURE__ */ new Set();
    const files = this.app.vault.getMarkdownFiles();
    const calloutRegex = /^>\s*\[!([^\]]+)\]/gm;
    for (const file of files) {
      if (this.shouldSkipFile(file.path, true))
        continue;
      try {
        const content = await this.app.vault.read(file);
        let match;
        let iterations = 0;
        const MAX_ITERATIONS = 1e3;
        calloutRegex.lastIndex = 0;
        while ((match = calloutRegex.exec(content)) !== null && iterations < MAX_ITERATIONS) {
          const type = match[1].toLowerCase().trim();
          calloutTypes.add(type);
          iterations++;
          if (match.index === calloutRegex.lastIndex) {
            calloutRegex.lastIndex++;
          }
        }
      } catch (error) {
        console.warn(`Failed to read file ${file.path} for callout scanning:`, error);
        continue;
      }
    }
    return calloutTypes;
  }
  isBuiltinCalloutType(type) {
    const builtinTypes = /* @__PURE__ */ new Set([
      // Blue family
      "note",
      "info",
      "todo",
      // Teal family
      "abstract",
      "summary",
      "tldr",
      "tip",
      "hint",
      "important",
      // Green family
      "success",
      "check",
      "done",
      // Orange family  
      "question",
      "help",
      "faq",
      "warning",
      "caution",
      "attention",
      // Red family
      "failure",
      "fail",
      "missing",
      "danger",
      "error",
      "bug",
      // Purple family
      "example",
      // Gray family
      "quote",
      "cite"
    ]);
    return builtinTypes.has(type.toLowerCase());
  }
  getDefaultColorForCalloutType(type) {
    const builtinColors = {
      // Blue family
      "note": "#086DDD",
      "info": "#086DDD",
      "todo": "#086DDD",
      // Teal family  
      "abstract": "#00BFBC",
      "summary": "#00BFBC",
      "tldr": "#00BFBC",
      "tip": "#00BFBC",
      "hint": "#00BFBC",
      "important": "#00BFBC",
      // Green family
      "success": "#08B94E",
      "check": "#08B94E",
      "done": "#08B94E",
      // Orange family
      "question": "#EC7500",
      "help": "#EC7500",
      "faq": "#EC7500",
      "warning": "#EC7500",
      "caution": "#EC7500",
      "attention": "#EC7500",
      // Red family
      "failure": "#E93147",
      "fail": "#E93147",
      "missing": "#E93147",
      "danger": "#E93147",
      "error": "#E93147",
      "bug": "#E93147",
      // Purple family
      "example": "#7852EE",
      // Gray family
      "quote": "#9E9E9E",
      "cite": "#9E9E9E",
      // Mathematical/Academic callouts (supporting academic workflows)
      "theorem": "#F19837",
      "lemma": "#F5CA00",
      "proposition": "#A28AE5",
      "definition": "#2EA4E5",
      "corollary": "#E56EEE",
      "conjecture": "#FF6699",
      "remark": "#FF6666",
      "exercise": "#FF6699",
      "problem": "#FF6699"
    };
    return builtinColors[type] || "#086DDD";
  }
  getDefaultIconForCalloutType(type) {
    const builtinIcons = {
      // Blue family
      "note": "pencil",
      "info": "info",
      "todo": "check-circle-2",
      // Teal family
      "abstract": "clipboard-list",
      "summary": "clipboard-list",
      "tldr": "clipboard-list",
      "tip": "flame",
      "hint": "flame",
      "important": "flame",
      // Green family
      "success": "check",
      "check": "check",
      "done": "check",
      // Orange family
      "question": "help-circle",
      "help": "help-circle",
      "faq": "help-circle",
      "warning": "alert-triangle",
      "caution": "alert-triangle",
      "attention": "alert-triangle",
      // Red family
      "failure": "x",
      "fail": "x",
      "missing": "x",
      "danger": "zap",
      "error": "zap",
      "bug": "bug",
      // Purple family
      "example": "list",
      // Gray family
      "quote": "quote",
      "cite": "quote",
      // Mathematical/Academic callouts (common in academic vaults)
      "theorem": "zap",
      "lemma": "lightbulb",
      "proposition": "star",
      "definition": "book-open",
      "corollary": "arrow-right",
      "conjecture": "help-circle",
      "remark": "message-circle",
      "exercise": "dumbbell",
      "problem": "puzzle"
    };
    return builtinIcons[type] || "pencil";
  }
  getObsidianCalloutColor(type) {
    var _a;
    const tempCallout = document.createElement("div");
    tempCallout.className = "callout";
    tempCallout.setAttribute("data-callout", type);
    tempCallout.style.position = "absolute";
    tempCallout.style.left = "-9999px";
    tempCallout.style.opacity = "0";
    document.body.appendChild(tempCallout);
    const computedStyle = getComputedStyle(tempCallout);
    const colorValue = computedStyle.getPropertyValue("--callout-color").trim();
    document.body.removeChild(tempCallout);
    if (colorValue && colorValue.includes(",")) {
      const colorParts = colorValue.split(",").map((x) => parseInt(x.trim()));
      if (colorParts.length >= 3 && colorParts.every((x) => !isNaN(x) && x >= 0 && x <= 255)) {
        const [r, g, b] = colorParts;
        return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}`;
      }
    }
    return ((_a = this.settings.calloutColors[type]) == null ? void 0 : _a.color) || "#448aff";
  }
  injectCustomCalloutCSS() {
    if (this.styleElement) {
      this.styleElement.remove();
    }
    this.styleElement = document.createElement("style");
    this.styleElement.id = "callout-organizer-custom-styles";
    let css = "";
    css += `
.callout-organizer-item {
    font-size: ${this.settings.calloutFontSize}px;
    --callout-font-size: ${this.settings.calloutFontSize}px;
}

.callout-organizer-breadcrumb {
    font-size: ${this.settings.breadcrumbFontSize}px;
}

/* Let native callouts in organizer use their natural styling */
.callout-organizer-item.callout {
    /* Minimal override - only set margin for organizer spacing */
    margin: 8px 0;
}`;
    for (const [type, colors] of Object.entries(this.settings.calloutColors)) {
      const rgbColor = this.hexToRgb(colors.color);
      const iconName = colors.icon || "none";
      if (this.isBuiltinCalloutType(type)) {
        const defaultColor = this.getDefaultColorForCalloutType(type);
        const defaultIcon = this.getDefaultIconForCalloutType(type);
        const hasCustomColor = colors.color !== defaultColor;
        const hasCustomIcon = colors.icon !== defaultIcon;
        if (hasCustomColor || hasCustomIcon) {
          css += `
/* User customized built-in callout: ${type} */
.callout[data-callout="${type}"].callout,
.callout-organizer-item.callout[data-callout="${type}"] {`;
          if (hasCustomColor) {
            css += `
    --callout-color: ${rgbColor} !important;
    --callout-border-color: ${rgbColor} !important;
    --callout-title-color: ${rgbColor} !important;`;
          }
          if (hasCustomIcon) {
            css += `
    --callout-icon: ${iconName === "none" ? "none" : `lucide-${iconName}`} !important;`;
          }
          css += `
}`;
        }
        css += `
.callout-filter-${type}.active {
    background: rgba(${rgbColor}, 0.2);
    border-color: rgb(${rgbColor});
    color: rgb(${rgbColor});
}`;
      } else {
        css += `
/* Custom callout styling for ${type} */
.callout[data-callout="${type}"].callout,
.callout-organizer-item.callout[data-callout="${type}"] {
    --callout-color: ${rgbColor} !important;
    --callout-border-color: ${rgbColor} !important;
    --callout-title-color: ${rgbColor} !important;
    --callout-icon: ${iconName === "none" ? "none" : `lucide-${iconName}`} !important;
}

.callout-filter-${type}.active {
    background: rgba(${rgbColor}, 0.2);
    border-color: rgb(${rgbColor});
    color: rgb(${rgbColor});
}`;
      }
    }
    if (this.settings.customCalloutCSS) {
      css += `
/* Custom Callout CSS - Global */
.callout {
    ${this.settings.customCalloutCSS}
}`;
    }
    if (this.settings.invisibleEmbeddings) {
      css += `
/* Invisible Embeddings */
.markdown-embed {
    padding: 0;
    border: 0;
}`;
    }
    this.styleElement.textContent = css;
    document.head.appendChild(this.styleElement);
  }
  async activateCalloutOrganizer() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_CALLOUT_ORGANIZER);
    const rightLeaf = this.app.workspace.getRightLeaf(false);
    if (rightLeaf) {
      await rightLeaf.setViewState({
        type: VIEW_TYPE_CALLOUT_ORGANIZER,
        active: true
      });
      const view = rightLeaf.view;
      if (view) {
        view.searchMode = "current";
      }
    }
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CALLOUT_ORGANIZER);
    if (leaves.length > 0) {
      this.app.workspace.revealLeaf(leaves[0]);
    }
  }
  getCalloutView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_CALLOUT_ORGANIZER);
    if (leaves.length > 0) {
      return leaves[0].view;
    }
    return null;
  }
  async extractCurrentFileCallouts() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile || !activeFile.path.endsWith(".md")) {
      return [];
    }
    return await this.extractCalloutsFromFile(activeFile);
  }
  async extractAllCallouts() {
    console.log("=== extractAllCallouts called ===");
    if (this.settings.enableFileCache) {
      console.log("File cache is enabled, checking for existing cache...");
      const cache = await this.loadCalloutCache();
      if (cache && await this.isCacheValid(cache)) {
        console.log(`\u2705 Using cached callouts: ${cache.callouts.length} items`);
        const sortedCallouts = [...cache.callouts].sort((a, b) => {
          const aModTime = a.calloutModifyTime || a.fileModTime || "1970-01-01 00:00:00";
          const bModTime = b.calloutModifyTime || b.fileModTime || "1970-01-01 00:00:00";
          return readableToTimestamp(bModTime) - readableToTimestamp(aModTime);
        });
        return sortedCallouts;
      } else {
        console.log("\u274C Cache invalid or not found, will scan files");
      }
    } else {
      console.log("File cache is disabled");
    }
    console.log("\u{1F4C1} Scanning all files for callouts...");
    const callouts = await this.scanAllCallouts();
    if (this.settings.enableFileCache) {
      console.log("\u{1F4BE} Saving to cache...");
      const saveResult = await this.saveCalloutCache(callouts);
      if (saveResult) {
        console.log(`\u2705 Saved ${callouts.length} callouts to cache`);
      } else {
        console.log("\u274C Failed to save to cache");
      }
    }
    return callouts;
  }
  async scanAllCallouts() {
    const callouts = [];
    const files = this.app.vault.getMarkdownFiles();
    const currentFile = this.app.workspace.getActiveFile();
    const processedFiles = /* @__PURE__ */ new Set();
    if (currentFile && currentFile.path.endsWith(".md")) {
      const currentFileCallouts = await this.extractCalloutsFromFile(currentFile);
      callouts.push(...currentFileCallouts);
      processedFiles.add(currentFile.path);
    }
    for (const file of files) {
      if (processedFiles.has(file.path) || this.shouldSkipFile(file.path, true))
        continue;
      const fileCallouts = await this.extractCalloutsFromFile(file);
      callouts.push(...fileCallouts);
      processedFiles.add(file.path);
    }
    return callouts;
  }
  async refreshAllCallouts() {
    console.log("Refreshing callouts - rescanning all files...");
    const callouts = await this.scanAllCallouts();
    if (this.settings.enableFileCache) {
      await this.saveCalloutCache(callouts);
      console.log(`Updated cache with ${callouts.length} callouts`);
    }
    return callouts;
  }
  shouldSkipFile(filePath, searchMode = false) {
    if (!searchMode)
      return false;
    const folders = this.settings.excludedFolders;
    if (folders.length === 0)
      return false;
    return folders.some(
      (folder) => filePath.startsWith(folder + "/") || filePath === folder
    );
  }
  // Create a unique signature for a callout to track its creation time
  createCalloutSignature(filePath, calloutID) {
    if (calloutID) {
      return `${filePath}:${calloutID}`;
    }
    const tempId = `temp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    return `${filePath}:${tempId}`;
  }
  async extractCalloutsFromFile(file) {
    var _a, _b;
    const content = await this.app.vault.read(file);
    const lines = content.split("\n");
    const callouts = [];
    const fileModTime = file.stat.mtime;
    const existingCache = await this.loadCalloutCache();
    const headingRegex = _CalloutOrganizerPlugin.HEADING_REGEX;
    const calloutRegex = _CalloutOrganizerPlugin.CALLOUT_REGEX;
    const blockIdRegex = _CalloutOrganizerPlugin.BLOCK_ID_REGEX;
    const allHeaders = [];
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.startsWith("#")) {
        const headingMatch = line.match(headingRegex);
        if (headingMatch) {
          allHeaders.push({
            title: headingMatch[2].trim(),
            level: headingMatch[1].length,
            lineNumber: i + 1
          });
        }
      }
    }
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (!line.startsWith(">"))
        continue;
      const calloutMatch = line.match(calloutRegex);
      if (calloutMatch) {
        const type = calloutMatch[1].toLowerCase();
        const title = calloutMatch[2].trim();
        const contentLines = [];
        let calloutID = "";
        let j = i + 1;
        for (; j < lines.length; j++) {
          const nextLine = lines[j];
          if (nextLine.startsWith(">")) {
            if (nextLine.includes("[!")) {
              const nextCalloutMatch = nextLine.match(calloutRegex);
              if (nextCalloutMatch) {
                break;
              }
            }
            const contentLine = nextLine.replace(/^>\s?/, "");
            const blockMatch = contentLine.match(blockIdRegex);
            if (blockMatch) {
              calloutID = blockMatch[1];
              const cleanContent = contentLine.replace(/\s*\^[\w-]+\s*$/, "");
              if (cleanContent)
                contentLines.push(cleanContent);
            } else {
              contentLines.push(contentLine);
            }
          } else if (nextLine.trim() === "") {
          } else {
            break;
          }
        }
        i = j - 1;
        const currentLineNumber = i + 1;
        const relevantHeaders = allHeaders.filter((header) => header.lineNumber <= currentLineNumber);
        const hierarchy = [];
        for (const heading of relevantHeaders) {
          while (hierarchy.length > 0 && hierarchy[hierarchy.length - 1].level >= heading.level) {
            hierarchy.pop();
          }
          hierarchy.push(heading);
        }
        let calloutSignature;
        if (calloutID) {
          calloutSignature = this.createCalloutSignature(file.path, calloutID);
        } else {
          calloutSignature = `${file.path}:${currentLineNumber}:${type}:${title}`;
        }
        const currentTime = Date.now();
        const currentReadableTime = timestampToReadable(currentTime);
        const fileModTimeReadable = timestampToReadable(fileModTime);
        const preliminaryCallout = {
          file: file.path,
          type,
          title,
          content: contentLines.join("\n").trim(),
          lineNumber: currentLineNumber,
          fileModTime: fileModTimeReadable
        };
        let creationTime;
        let modificationTime;
        if (calloutID) {
          if ((_a = existingCache == null ? void 0 : existingCache.calloutCreationTimes) == null ? void 0 : _a[calloutSignature]) {
            creationTime = existingCache.calloutCreationTimes[calloutSignature];
            const existingCallout = (_b = existingCache.callouts) == null ? void 0 : _b.find(
              (c) => c.calloutID === calloutID && c.file === file.path
            );
            if (existingCallout && hasCalloutChanged(preliminaryCallout, existingCallout)) {
              modificationTime = currentReadableTime;
            } else {
              modificationTime = (existingCallout == null ? void 0 : existingCallout.calloutModifyTime) || currentReadableTime;
            }
          } else {
            creationTime = currentReadableTime;
            modificationTime = currentReadableTime;
          }
        } else {
          creationTime = fileModTimeReadable;
          modificationTime = fileModTimeReadable;
        }
        const calloutItem = {
          file: file.path,
          type,
          title,
          content: contentLines.join("\n").trim(),
          lineNumber: currentLineNumber,
          fileModTime: fileModTimeReadable,
          calloutCreatedTime: creationTime,
          calloutModifyTime: modificationTime
        };
        if (calloutID)
          calloutItem.calloutID = calloutID;
        if (hierarchy.length > 0) {
          calloutItem.headers = hierarchy.map((h) => h.title);
          calloutItem.headerLevels = hierarchy.map((h) => h.level);
        }
        callouts.push(calloutItem);
      }
    }
    return callouts;
  }
  // Cache management methods
  getCacheFilePath() {
    return `.obsidian/plugins/${_CalloutOrganizerPlugin.PLUGIN_FOLDER}/${_CalloutOrganizerPlugin.CACHE_FILENAME}`;
  }
  async loadCalloutCache() {
    if (!this.settings.enableFileCache) {
      return null;
    }
    try {
      const fs = require("fs");
      const path = require("path");
      const adapter = this.app.vault.adapter;
      if (!(adapter == null ? void 0 : adapter.basePath)) {
        console.warn("Unable to access vault adapter base path");
        return null;
      }
      const dataDir = adapter.basePath;
      const cachePath = path.join(dataDir, ".obsidian", "plugins", _CalloutOrganizerPlugin.PLUGIN_FOLDER, _CalloutOrganizerPlugin.CACHE_FILENAME);
      console.log(`Attempting to load cache from: ${cachePath}`);
      if (!fs.existsSync(cachePath)) {
        console.log("Cache file does not exist");
        return null;
      }
      const cacheContent = fs.readFileSync(cachePath, "utf8");
      const cache = JSON.parse(cacheContent);
      if (!cache.calloutCreationTimes) {
        cache.calloutCreationTimes = {};
      } else {
        const convertedTimes = {};
        for (const [signature, time] of Object.entries(cache.calloutCreationTimes)) {
          if (typeof time === "number") {
            convertedTimes[signature] = timestampToReadable(time);
          } else {
            convertedTimes[signature] = time;
          }
        }
        cache.calloutCreationTimes = convertedTimes;
      }
      if (cache.fileModTimes) {
        const convertedFileModTimes = {};
        for (const [filePath, time] of Object.entries(cache.fileModTimes)) {
          if (typeof time === "number") {
            convertedFileModTimes[filePath] = timestampToReadable(time);
          } else {
            convertedFileModTimes[filePath] = time;
          }
        }
        cache.fileModTimes = convertedFileModTimes;
      }
      if (cache.callouts) {
        for (const callout of cache.callouts) {
          if (callout.fileModTime && typeof callout.fileModTime === "number") {
            callout.fileModTime = timestampToReadable(callout.fileModTime);
          }
          if (callout.calloutCreatedTime && typeof callout.calloutCreatedTime === "number") {
            callout.calloutCreatedTime = timestampToReadable(callout.calloutCreatedTime);
          }
          if (callout.calloutModifyTime && typeof callout.calloutModifyTime === "number") {
            callout.calloutModifyTime = timestampToReadable(callout.calloutModifyTime);
          }
        }
      }
      if (cache.version !== _CalloutOrganizerPlugin.CACHE_VERSION) {
        console.log("Cache version mismatch, invalidating cache");
        return null;
      }
      const currentVaultPath = this.app.vault.getName() || "";
      if (cache.vaultPath !== currentVaultPath) {
        console.log(`Vault path changed (${cache.vaultPath} != ${currentVaultPath}), invalidating cache`);
        return null;
      }
      console.log(`\u2705 Successfully loaded ${cache.callouts.length} callouts from plugin folder cache`);
      return cache;
    } catch (error) {
      console.warn("Failed to load callout cache:", error);
      return null;
    }
  }
  async saveCalloutCache(callouts) {
    if (!this.settings.enableFileCache) {
      console.log("File cache is disabled, skipping save");
      return false;
    }
    console.log(`Attempting to save ${callouts.length} callouts to cache...`);
    try {
      const fileModTimes = {};
      const files = this.app.vault.getMarkdownFiles();
      for (const file of files) {
        if (!this.shouldSkipFile(file.path, true)) {
          fileModTimes[file.path] = timestampToReadable(file.stat.mtime);
        }
      }
      const calloutCreationTimes = {};
      for (const callout of callouts) {
        if (callout.calloutCreatedTime) {
          let signature;
          if (callout.calloutID) {
            signature = this.createCalloutSignature(callout.file, callout.calloutID);
          } else {
            signature = `${callout.file}:${callout.lineNumber}:${callout.type}:${callout.title}`;
          }
          calloutCreationTimes[signature] = callout.calloutCreatedTime;
        }
      }
      const cache = {
        version: _CalloutOrganizerPlugin.CACHE_VERSION,
        timestamp: Date.now(),
        vaultPath: this.app.vault.getName() || "",
        callouts,
        fileModTimes,
        calloutCreationTimes
      };
      const fs = require("fs");
      const path = require("path");
      const adapter = this.app.vault.adapter;
      if (!(adapter == null ? void 0 : adapter.basePath)) {
        console.warn("Unable to access vault adapter base path");
        return false;
      }
      const dataDir = adapter.basePath;
      const cacheFilePath = path.join(dataDir, ".obsidian", "plugins", _CalloutOrganizerPlugin.PLUGIN_FOLDER, _CalloutOrganizerPlugin.CACHE_FILENAME);
      const cacheContent = JSON.stringify(cache, null, 2);
      console.log(`Saving cache to: ${cacheFilePath}`);
      fs.writeFileSync(cacheFilePath, cacheContent, "utf8");
      console.log("\u2705 Cache file saved successfully to plugin folder");
      return true;
    } catch (error) {
      console.error("Failed to save callout cache:", error);
      return false;
    }
  }
  async isCacheValid(cache) {
    if (!cache || !this.settings.enableFileCache) {
      return false;
    }
    try {
      for (const [filePath, cachedModTime] of Object.entries(cache.fileModTimes)) {
        const file = this.app.vault.getAbstractFileByPath(filePath);
        if (file instanceof import_obsidian.TFile) {
          if (file.stat.mtime > readableToTimestamp(cachedModTime)) {
            console.log(`File ${filePath} has been modified, cache invalid`);
            return false;
          }
        } else {
          console.log(`File ${filePath} no longer exists, cache invalid`);
          return false;
        }
      }
      const currentFiles = this.app.vault.getMarkdownFiles();
      for (const file of currentFiles) {
        if (!this.shouldSkipFile(file.path, true) && !cache.fileModTimes.hasOwnProperty(file.path)) {
          console.log(`New file ${file.path} found, cache invalid`);
          return false;
        }
      }
      return true;
    } catch (error) {
      console.warn("Error validating cache:", error);
      return false;
    }
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_CALLOUT_ORGANIZER);
    if (this.styleElement) {
      this.styleElement.remove();
      this.styleElement = null;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var CalloutOrganizerPlugin = _CalloutOrganizerPlugin;
// Static regex patterns for better performance
CalloutOrganizerPlugin.HEADING_REGEX = /^(#{1,6})\s+(.+)$/;
CalloutOrganizerPlugin.CALLOUT_REGEX = /^>\s*\[!([^\]]+)\]\s*(.*?)$/;
CalloutOrganizerPlugin.BLOCK_ID_REGEX = /\^([\w-]+)\s*$/;
CalloutOrganizerPlugin.CONTENT_EXTRACT_REGEX = /^>\s?/;
// Cache constants
CalloutOrganizerPlugin.CACHE_VERSION = "1.3";
CalloutOrganizerPlugin.PLUGIN_FOLDER = "callout-organizer";
CalloutOrganizerPlugin.CACHE_FILENAME = "callouts.json";
var CalloutOrganizerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Callout Organizer Settings" });
    containerEl.createEl("h3", { text: "Performance Options" });
    const performanceContainer = containerEl.createEl("div", { cls: "callout-settings-indent" });
    new import_obsidian.Setting(performanceContainer).setName("Enable File Cache").setDesc("Cache callouts in a file to improve startup performance. Disabling this will scan all files each time.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableFileCache).onChange(async (value) => {
      this.plugin.settings.enableFileCache = value;
      await this.plugin.saveSettings();
      if (value) {
        new import_obsidian.Notice("File cache enabled. Callouts will be cached for faster startup.");
      } else {
        new import_obsidian.Notice("File cache disabled. Plugin will scan files on each startup.");
        try {
          const cacheFilePath = this.plugin.getCacheFilePath();
          const cacheFile = this.app.vault.getAbstractFileByPath(cacheFilePath);
          if (cacheFile && cacheFile instanceof import_obsidian.TFile) {
            await this.app.vault.delete(cacheFile);
            console.log("Cache file deleted via Obsidian API");
          }
          const fs = require("fs");
          const path = require("path");
          const adapter = this.app.vault.adapter;
          if (!(adapter == null ? void 0 : adapter.basePath)) {
            console.warn("Unable to access vault adapter base path");
            return null;
          }
          const dataDir = adapter.basePath;
          const pluginCachePath = path.join(dataDir, ".obsidian", "plugins", "callout-organizer", "callouts.json");
          if (fs.existsSync(pluginCachePath)) {
            fs.unlinkSync(pluginCachePath);
            console.log("Plugin folder cache file also deleted");
          }
        } catch (error) {
          console.warn("Failed to delete cache file:", error);
        }
      }
    }));
    containerEl.createEl("h3", { text: "Display Options" });
    const displayContainer = containerEl.createEl("div", { cls: "callout-settings-indent" });
    new import_obsidian.Setting(displayContainer).setName("Show Filenames").setDesc("Display filenames in the breadcrumb navigation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showFilenames).onChange(async (value) => {
      this.plugin.settings.showFilenames = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Show H1 Headers").setDesc("Display H1 headers (# Header) in the breadcrumb navigation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showH1Headers).onChange(async (value) => {
      this.plugin.settings.showH1Headers = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Show H2 Headers").setDesc("Display H2 headers (## Header) in the breadcrumb navigation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showH2Headers).onChange(async (value) => {
      this.plugin.settings.showH2Headers = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Show H3 Headers").setDesc("Display H3 headers (### Header) in the breadcrumb navigation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showH3Headers).onChange(async (value) => {
      this.plugin.settings.showH3Headers = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Show H4 Headers").setDesc("Display H4 headers (#### Header) in the breadcrumb navigation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showH4Headers).onChange(async (value) => {
      this.plugin.settings.showH4Headers = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Show H5 Headers").setDesc("Display H5 headers (##### Header) in the breadcrumb navigation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showH5Headers).onChange(async (value) => {
      this.plugin.settings.showH5Headers = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Show H6 Headers").setDesc("Display H6 headers (###### Header) in the breadcrumb navigation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showH6Headers).onChange(async (value) => {
      this.plugin.settings.showH6Headers = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Show Callout IDs").setDesc("Display callout block IDs (^callout-id) in the breadcrumb navigation").addToggle((toggle) => toggle.setValue(this.plugin.settings.showCalloutIds).onChange(async (value) => {
      this.plugin.settings.showCalloutIds = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Callout Font Size").setDesc("Font size for callout content in pixels").addText((text) => text.setPlaceholder("14").setValue(this.plugin.settings.calloutFontSize.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.calloutFontSize = numValue;
        await this.plugin.saveSettings();
        this.plugin.injectCustomCalloutCSS();
      }
    }));
    new import_obsidian.Setting(displayContainer).setName("Breadcrumb Font Size").setDesc("Font size for breadcrumb navigation in pixels").addText((text) => text.setPlaceholder("12").setValue(this.plugin.settings.breadcrumbFontSize.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.breadcrumbFontSize = numValue;
        await this.plugin.saveSettings();
        this.plugin.injectCustomCalloutCSS();
      }
    }));
    containerEl.createEl("h3", { text: "Drag Options" });
    const dragContainer = containerEl.createEl("div", { cls: "callout-settings-indent" });
    new import_obsidian.Setting(dragContainer).setName("Use Embed Links").setDesc("Use embed links (![[...]]) instead of regular links ([[...]]) when dragging callouts").addToggle((toggle) => toggle.setValue(this.plugin.settings.useEmbedLinks).onChange(async (value) => {
      this.plugin.settings.useEmbedLinks = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(dragContainer).setName("Invisible Embeddings").setDesc("Make embedded callouts appear seamlessly without padding or borders").addToggle((toggle) => toggle.setValue(this.plugin.settings.invisibleEmbeddings).onChange(async (value) => {
      this.plugin.settings.invisibleEmbeddings = value;
      await this.plugin.saveSettings();
      this.plugin.injectCustomCalloutCSS();
    }));
    new import_obsidian.Setting(dragContainer).setName("Hide file names in links").setDesc("When dragging callouts, hide file names by adding aliases. Example: [[filename#^theorem-def456|theorem-def456]]").addToggle((toggle) => toggle.setValue(this.plugin.settings.hideFileNamesInLinks).onChange(async (value) => {
      this.plugin.settings.hideFileNamesInLinks = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Search Options" });
    const searchContainer = containerEl.createEl("div", { cls: "callout-settings-indent" });
    new import_obsidian.Setting(searchContainer).setName("Excluded Folders").setDesc("Exclude these folders from search (comma-separated)").addTextArea((text) => text.setPlaceholder("folder1, folder2/subfolder").setValue(this.plugin.settings.excludedFolders.join(", ")).onChange(async (value) => {
      this.plugin.settings.excludedFolders = value.split(",").map((s) => s.trim()).filter((s) => s);
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(searchContainer).setName("Maximum Search Results").setDesc("Limit the number of search results to improve performance").addText((text) => text.setPlaceholder("50").setValue(this.plugin.settings.maxSearchResults.toString()).onChange(async (value) => {
      const numValue = parseInt(value);
      if (!isNaN(numValue) && numValue > 0) {
        this.plugin.settings.maxSearchResults = numValue;
        await this.plugin.saveSettings();
      }
    }));
    new import_obsidian.Setting(searchContainer).setName("Search in Filenames").setDesc("Include file paths and names in search results").addToggle((toggle) => toggle.setValue(this.plugin.settings.searchInFilenames).onChange(async (value) => {
      this.plugin.settings.searchInFilenames = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(searchContainer).setName("Search in Callout Titles").setDesc("Include callout titles (> [!type] Callout Titles) in search results").addToggle((toggle) => toggle.setValue(this.plugin.settings.searchInCalloutTitles).onChange(async (value) => {
      this.plugin.settings.searchInCalloutTitles = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(searchContainer).setName("Search in Callout IDs").setDesc("Include callout identifiers (^callout-id) in search results").addToggle((toggle) => toggle.setValue(this.plugin.settings.searchInCalloutIds).onChange(async (value) => {
      this.plugin.settings.searchInCalloutIds = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    new import_obsidian.Setting(searchContainer).setName("Search in Callout Content").setDesc("Include callout content/body text in search results").addToggle((toggle) => toggle.setValue(this.plugin.settings.searchInCalloutContent).onChange(async (value) => {
      this.plugin.settings.searchInCalloutContent = value;
      await this.plugin.saveSettings();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
    }));
    containerEl.createEl("h3", { text: "Callout Options" });
    const calloutOptionsContainer = containerEl.createEl("div", { cls: "callout-settings-indent" });
    calloutOptionsContainer.createEl("p", {
      text: "\u{1F4A1} Note: Some CSS changes may require restarting Obsidian to take full effect.",
      cls: "setting-item-description"
    });
    const githubLinkContainer = calloutOptionsContainer.createEl("p", {
      cls: "setting-item-description"
    });
    githubLinkContainer.createEl("span", {
      text: "See recommended CSS snippets and colors at: "
    });
    const githubLink = githubLinkContainer.createEl("a", {
      text: "https://github.com/mathmaid/obsidian-callout-organizer",
      href: "https://github.com/mathmaid/obsidian-callout-organizer"
    });
    githubLink.addEventListener("click", (e) => {
      e.preventDefault();
      window.open("https://github.com/mathmaid/obsidian-callout-organizer", "_blank");
    });
    calloutOptionsContainer.createEl("h4", { text: "Custom CSS" });
    new import_obsidian.Setting(calloutOptionsContainer).setName("Custom Callout CSS").setDesc("Add custom CSS properties that apply to ALL callouts throughout Obsidian (editor and plugin)").addTextArea((text) => {
      text.setPlaceholder("/* custom css snippets */");
      text.setValue(this.plugin.settings.customCalloutCSS);
      text.onChange(async (value) => {
        this.plugin.settings.customCalloutCSS = value;
        await this.plugin.saveSettings();
        this.plugin.injectCustomCalloutCSS();
      });
    });
    calloutOptionsContainer.createEl("h4", { text: "Callout Colors" });
    const colorsContainer = calloutOptionsContainer.createEl("div");
    colorsContainer.createEl("p", {
      text: "Customize colors for callout types found in your vault. New callout types are automatically detected.",
      cls: "setting-item-description"
    });
    this.createDynamicCalloutColorSettings(colorsContainer);
  }
  async createDynamicCalloutColorSettings(container) {
    const loadingEl = container.createEl("p", { text: "Scanning vault for callout types...", cls: "setting-item-description" });
    try {
      const detectedTypes = await this.plugin.getAllCalloutTypesInVault();
      const sortedTypes = Array.from(detectedTypes).sort();
      loadingEl.remove();
      if (sortedTypes.length === 0) {
        container.createEl("p", { text: "No callouts found in your vault.", cls: "setting-item-description" });
        return;
      }
      for (const type of sortedTypes) {
        if (!this.plugin.settings.calloutColors[type]) {
          if (this.plugin.isBuiltinCalloutType(type)) {
            const obsidianColor = this.plugin.getObsidianCalloutColor(type);
            this.plugin.settings.calloutColors[type] = {
              color: obsidianColor,
              icon: this.plugin.getDefaultIconForCalloutType(type)
            };
          } else {
            this.plugin.settings.calloutColors[type] = {
              color: this.getDefaultColorForType(type),
              icon: this.getDefaultIconForCalloutType(type)
            };
          }
        } else if (!this.plugin.settings.calloutColors[type].icon) {
          this.plugin.settings.calloutColors[type].icon = this.getDefaultIconForCalloutType(type);
        }
      }
      await this.plugin.saveSettings();
      this.plugin.injectCustomCalloutCSS();
      const view = this.plugin.getCalloutView();
      if (view) {
        await view.refreshCallouts();
      }
      container.createEl("p", {
        text: `Found ${sortedTypes.length} callout types in your vault.`,
        cls: "setting-item-description"
      });
      const builtinTypes = sortedTypes.filter((type) => this.plugin.isBuiltinCalloutType(type));
      const userTypes = sortedTypes.filter((type) => !this.plugin.isBuiltinCalloutType(type));
      if (builtinTypes.length > 0) {
        container.createEl("h5", { text: "Built-in Obsidian Callouts" });
        container.createEl("p", {
          text: `${builtinTypes.length} built-in callout types. Reset button restores Obsidian defaults.`,
          cls: "setting-item-description"
        });
        for (const type of builtinTypes) {
          const colors = this.plugin.settings.calloutColors[type];
          this.createCalloutSetting(container, type, colors, true);
        }
      }
      if (userTypes.length > 0) {
        container.createEl("h5", { text: "Custom Callouts" });
        container.createEl("p", {
          text: `${userTypes.length} custom callout types. Reset button sets to note callout defaults.`,
          cls: "setting-item-description"
        });
        for (const type of userTypes) {
          const colors = this.plugin.settings.calloutColors[type];
          this.createCalloutSetting(container, type, colors, false);
        }
      }
    } catch (error) {
      loadingEl.textContent = "Error scanning vault for callouts.";
      console.error("Error scanning for callouts:", error);
    }
  }
  createCalloutSetting(container, type, colors, isBuiltin) {
    const setting = new import_obsidian.Setting(container).setName(`${type.charAt(0).toUpperCase() + type.slice(1)} Callout`);
    const iconPreview = setting.controlEl.createDiv({ cls: "callout-icon-preview" });
    const updateIconPreview = () => {
      iconPreview.empty();
      if (colors.icon && colors.icon !== "none") {
        if (type === "note" && colors.icon === "pencil") {
          iconPreview.innerHTML = OBSIDIAN_NOTE_ICON_SVG;
        } else {
          (0, import_obsidian.setIcon)(iconPreview, colors.icon);
        }
        iconPreview.style.color = colors.color;
      }
    };
    updateIconPreview();
    let colorPicker;
    let dropdownRef;
    setting.addColorPicker((color) => {
      colorPicker = color;
      return color.setValue(colors.color).onChange(async (value) => {
        this.plugin.settings.calloutColors[type].color = value;
        await this.plugin.saveSettings();
        this.plugin.injectCustomCalloutCSS();
        updateIconPreview();
        const view = this.plugin.getCalloutView();
        if (view) {
          await view.refreshCallouts();
        }
      });
    }).addDropdown((dropdown) => {
      dropdownRef = dropdown;
      dropdown.addOption("none", "No Icon");
      const lucideIcons = [
        // Basic shapes and symbols
        "circle",
        "square",
        "triangle",
        "diamond",
        "hexagon",
        "star",
        "heart",
        // UI and interface
        "pencil",
        "edit",
        "edit-2",
        "edit-3",
        "pen-tool",
        "brush",
        "palette",
        "info",
        "alert-circle",
        "alert-triangle",
        "alert-octagon",
        "help-circle",
        "question-mark",
        "exclamation",
        "check",
        "check-circle",
        "check-circle-2",
        "x",
        "x-circle",
        "minus",
        "minus-circle",
        "plus",
        "plus-circle",
        // Files and documents
        "file",
        "file-text",
        "book",
        "book-open",
        "notebook",
        "scroll",
        "document",
        "page",
        "pages",
        "bookmark",
        "tag",
        "tags",
        "clipboard-list",
        // Communication and social
        "message-circle",
        "message-square",
        "quote",
        "speech",
        "comment",
        "chat",
        "mail",
        "phone",
        "bell",
        "megaphone",
        // Technology and tools
        "zap",
        "flash",
        "bolt",
        "cpu",
        "hard-drive",
        "database",
        "server",
        "code",
        "terminal",
        "command",
        "bug",
        "wrench",
        "tool",
        "settings",
        // Science and education
        "atom",
        "beaker",
        "flask",
        "microscope",
        "telescope",
        "graduation-cap",
        "calculator",
        "ruler",
        "compass",
        "protractor",
        "formula",
        // Nature and objects
        "sun",
        "moon",
        "star-filled",
        "cloud",
        "umbrella",
        "tree",
        "flower",
        "leaf",
        "flame",
        "droplet",
        "snowflake",
        // Navigation and movement
        "arrow-up",
        "arrow-down",
        "arrow-left",
        "arrow-right",
        "navigation",
        "compass-2",
        "map",
        "map-pin",
        "target",
        "crosshair",
        // Time and calendar
        "clock",
        "watch",
        "timer",
        "calendar",
        "calendar-days",
        "hourglass",
        // Media and entertainment
        "image",
        "camera",
        "video",
        "music",
        "headphones",
        "mic",
        "play",
        "pause",
        "stop",
        "film",
        "tv",
        // Business and finance
        "briefcase",
        "building",
        "bank",
        "credit-card",
        "dollar-sign",
        "trending-up",
        "trending-down",
        "bar-chart",
        "pie-chart",
        // Health and medical
        "activity",
        "heart-pulse",
        "pill",
        "syringe",
        "thermometer",
        "first-aid",
        "cross",
        "shield",
        "shield-check",
        // Transportation
        "car",
        "truck",
        "bike",
        "plane",
        "ship",
        "train",
        "bus",
        // Food and dining
        "coffee",
        "cup",
        "utensils",
        "pizza",
        "apple",
        "cherry",
        // Sports and games
        "gamepad",
        "dice",
        "trophy",
        "medal",
        "flag",
        "target-2",
        // Miscellaneous
        "lightbulb",
        "key",
        "lock",
        "unlock",
        "eye",
        "eye-off",
        "glasses",
        "gem",
        "gift",
        "magic-wand",
        "puzzle",
        "layers",
        "layout",
        "grid",
        "list",
        "menu",
        "more-horizontal"
      ];
      lucideIcons.forEach((icon) => {
        dropdown.addOption(icon, icon.charAt(0).toUpperCase() + icon.slice(1).replace(/-/g, " "));
      });
      dropdown.setValue(colors.icon || "none");
      dropdown.onChange(async (value) => {
        this.plugin.settings.calloutColors[type].icon = value;
        await this.plugin.saveSettings();
        this.plugin.injectCustomCalloutCSS();
        updateIconPreview();
        const view = this.plugin.getCalloutView();
        if (view) {
          await view.refreshCallouts();
        }
      });
      return dropdown;
    }).addButton((button) => {
      const tooltipText = isBuiltin ? "Reset to Obsidian default color and icon" : "Reset to note callout defaults";
      button.setTooltip(tooltipText);
      (0, import_obsidian.setIcon)(button.buttonEl, "rotate-ccw");
      button.onClick(async () => {
        let defaultColor;
        let defaultIcon;
        if (isBuiltin) {
          defaultColor = this.plugin.getDefaultColorForCalloutType(type);
          defaultIcon = this.plugin.getDefaultIconForCalloutType(type);
        } else {
          defaultColor = this.plugin.getDefaultColorForCalloutType("note");
          defaultIcon = this.plugin.getDefaultIconForCalloutType("note");
        }
        this.plugin.settings.calloutColors[type].color = defaultColor;
        this.plugin.settings.calloutColors[type].icon = defaultIcon;
        await this.plugin.saveSettings();
        this.plugin.injectCustomCalloutCSS();
        if (dropdownRef)
          dropdownRef.setValue(defaultIcon);
        if (colorPicker)
          colorPicker.setValue(defaultColor);
        updateIconPreview();
        const view = this.plugin.getCalloutView();
        if (view) {
          await view.refreshCallouts();
        }
      });
    });
  }
  getDefaultColorForType(type) {
    return this.plugin.getDefaultColorForCalloutType(type);
  }
  getDefaultIconForCalloutType(type) {
    return this.plugin.getDefaultIconForCalloutType(type);
  }
};
